import {
  __commonJS
} from "./chunk-LXYNHJXE.js";

// node_modules/postscribe/dist/postscribe.js
var require_postscribe = __commonJS({
  "node_modules/postscribe/dist/postscribe.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["postscribe"] = factory();
      else
        root["postscribe"] = factory();
    })(exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId])
              return installedModules[moduleId].exports;
            var module2 = installedModules[moduleId] = {
              /******/
              exports: {},
              /******/
              id: moduleId,
              /******/
              loaded: false
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.loaded = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.p = "";
          return __webpack_require__(0);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _postscribe = __webpack_require__(1);
            var _postscribe2 = _interopRequireDefault(_postscribe);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            module2.exports = _postscribe2["default"];
          },
          /* 1 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            exports2["default"] = postscribe;
            var _writeStream = __webpack_require__(2);
            var _writeStream2 = _interopRequireDefault(_writeStream);
            var _utils = __webpack_require__(4);
            var utils = _interopRequireWildcard(_utils);
            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) {
                return obj;
              } else {
                var newObj = {};
                if (obj != null) {
                  for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key))
                      newObj[key] = obj[key];
                  }
                }
                newObj["default"] = obj;
                return newObj;
              }
            }
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            function doNothing() {
            }
            var OPTIONS = {
              /**
               * Called when an async script has loaded.
               */
              afterAsync: doNothing,
              /**
               * Called immediately before removing from the write queue.
               */
              afterDequeue: doNothing,
              /**
               * Called sync after a stream's first thread release.
               */
              afterStreamStart: doNothing,
              /**
               * Called after writing buffered document.write calls.
               */
              afterWrite: doNothing,
              /**
               * Allows disabling the autoFix feature of prescribe
               */
              autoFix: true,
              /**
               * Called immediately before adding to the write queue.
               */
              beforeEnqueue: doNothing,
              /**
               * Called before writing a token.
               *
               * @param {Object} tok The token
               */
              beforeWriteToken: function beforeWriteToken(tok) {
                return tok;
              },
              /**
               * Called before writing buffered document.write calls.
               *
               * @param {String} str The string
               */
              beforeWrite: function beforeWrite(str) {
                return str;
              },
              /**
               * Called when evaluation is finished.
               */
              done: doNothing,
              /**
               * Called when a write results in an error.
               *
               * @param {Error} e The error
               */
              error: function error(e) {
                throw new Error(e.msg);
              },
              /**
               * Whether to let scripts w/ async attribute set fall out of the queue.
               */
              releaseAsync: false
            };
            var nextId = 0;
            var queue = [];
            var active = null;
            function nextStream() {
              var args = queue.shift();
              if (args) {
                var options = utils.last(args);
                options.afterDequeue();
                args.stream = runStream.apply(void 0, args);
                options.afterStreamStart();
              }
            }
            function runStream(el, html, options) {
              active = new _writeStream2["default"](el, options);
              active.id = nextId++;
              active.name = options.name || active.id;
              postscribe.streams[active.name] = active;
              var doc = el.ownerDocument;
              var stash = {
                close: doc.close,
                open: doc.open,
                write: doc.write,
                writeln: doc.writeln
              };
              function _write(str) {
                str = options.beforeWrite(str);
                active.write(str);
                options.afterWrite(str);
              }
              _extends(doc, {
                close: doNothing,
                open: doNothing,
                write: function write() {
                  for (var _len = arguments.length, str = Array(_len), _key = 0; _key < _len; _key++) {
                    str[_key] = arguments[_key];
                  }
                  return _write(str.join(""));
                },
                writeln: function writeln() {
                  for (var _len2 = arguments.length, str = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    str[_key2] = arguments[_key2];
                  }
                  return _write(str.join("") + "\n");
                }
              });
              var oldOnError = active.win.onerror || doNothing;
              active.win.onerror = function(msg, url, line) {
                options.error({ msg: msg + " - " + url + ": " + line });
                oldOnError.apply(active.win, [msg, url, line]);
              };
              active.write(html, function() {
                _extends(doc, stash);
                active.win.onerror = oldOnError;
                options.done();
                active = null;
                nextStream();
              });
              return active;
            }
            function postscribe(el, html, options) {
              if (utils.isFunction(options)) {
                options = { done: options };
              } else if (options === "clear") {
                queue = [];
                active = null;
                nextId = 0;
                return;
              }
              options = utils.defaults(options, OPTIONS);
              if (/^#/.test(el)) {
                el = window.document.getElementById(el.substr(1));
              } else {
                el = el.jquery ? el[0] : el;
              }
              var args = [el, html, options];
              el.postscribe = {
                cancel: function cancel() {
                  if (args.stream) {
                    args.stream.abort();
                  } else {
                    args[1] = doNothing;
                  }
                }
              };
              options.beforeEnqueue(args);
              queue.push(args);
              if (!active) {
                nextStream();
              }
              return el.postscribe;
            }
            _extends(postscribe, {
              // Streams by name.
              streams: {},
              // Queue of streams.
              queue,
              // Expose internal classes.
              WriteStream: _writeStream2["default"]
            });
          },
          /* 2 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            var _prescribe = __webpack_require__(3);
            var _prescribe2 = _interopRequireDefault(_prescribe);
            var _utils = __webpack_require__(4);
            var utils = _interopRequireWildcard(_utils);
            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) {
                return obj;
              } else {
                var newObj = {};
                if (obj != null) {
                  for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key))
                      newObj[key] = obj[key];
                  }
                }
                newObj["default"] = obj;
                return newObj;
              }
            }
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var DEBUG_CHUNK = false;
            var BASEATTR = "data-ps-";
            var PROXY_STYLE = "ps-style";
            var PROXY_SCRIPT = "ps-script";
            function getData(el, name) {
              var attr = BASEATTR + name;
              var val = el.getAttribute(attr);
              return !utils.existy(val) ? val : String(val);
            }
            function setData(el, name) {
              var value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              var attr = BASEATTR + name;
              if (utils.existy(value) && value !== "") {
                el.setAttribute(attr, value);
              } else {
                el.removeAttribute(attr);
              }
            }
            var WriteStream = function() {
              function WriteStream2(root) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                _classCallCheck(this, WriteStream2);
                this.root = root;
                this.options = options;
                this.doc = root.ownerDocument;
                this.win = this.doc.defaultView || this.doc.parentWindow;
                this.parser = new _prescribe2["default"]("", { autoFix: options.autoFix });
                this.actuals = [root];
                this.proxyHistory = "";
                this.proxyRoot = this.doc.createElement(root.nodeName);
                this.scriptStack = [];
                this.writeQueue = [];
                setData(this.proxyRoot, "proxyof", 0);
              }
              WriteStream2.prototype.write = function write() {
                var _writeQueue;
                (_writeQueue = this.writeQueue).push.apply(_writeQueue, arguments);
                while (!this.deferredRemote && this.writeQueue.length) {
                  var arg = this.writeQueue.shift();
                  if (utils.isFunction(arg)) {
                    this._callFunction(arg);
                  } else {
                    this._writeImpl(arg);
                  }
                }
              };
              WriteStream2.prototype._callFunction = function _callFunction(fn) {
                var tok = { type: "function", value: fn.name || fn.toString() };
                this._onScriptStart(tok);
                fn.call(this.win, this.doc);
                this._onScriptDone(tok);
              };
              WriteStream2.prototype._writeImpl = function _writeImpl(html) {
                this.parser.append(html);
                var tok = void 0;
                var script = void 0;
                var style = void 0;
                var tokens = [];
                while ((tok = this.parser.readToken()) && !(script = utils.isScript(tok)) && !(style = utils.isStyle(tok))) {
                  tok = this.options.beforeWriteToken(tok);
                  if (tok) {
                    tokens.push(tok);
                  }
                }
                if (tokens.length > 0) {
                  this._writeStaticTokens(tokens);
                }
                if (script) {
                  this._handleScriptToken(tok);
                }
                if (style) {
                  this._handleStyleToken(tok);
                }
              };
              WriteStream2.prototype._writeStaticTokens = function _writeStaticTokens(tokens) {
                var chunk = this._buildChunk(tokens);
                if (!chunk.actual) {
                  return null;
                }
                chunk.html = this.proxyHistory + chunk.actual;
                this.proxyHistory += chunk.proxy;
                this.proxyRoot.innerHTML = chunk.html;
                if (DEBUG_CHUNK) {
                  chunk.proxyInnerHTML = this.proxyRoot.innerHTML;
                }
                this._walkChunk();
                if (DEBUG_CHUNK) {
                  chunk.actualInnerHTML = this.root.innerHTML;
                }
                return chunk;
              };
              WriteStream2.prototype._buildChunk = function _buildChunk(tokens) {
                var nextId = this.actuals.length;
                var raw = [];
                var actual = [];
                var proxy = [];
                var len = tokens.length;
                for (var i = 0; i < len; i++) {
                  var tok = tokens[i];
                  var tokenRaw = tok.toString();
                  raw.push(tokenRaw);
                  if (tok.attrs) {
                    if (!/^noscript$/i.test(tok.tagName)) {
                      var id = nextId++;
                      actual.push(tokenRaw.replace(/(\/?>)/, " " + BASEATTR + "id=" + id + " $1"));
                      if (tok.attrs.id !== PROXY_SCRIPT && tok.attrs.id !== PROXY_STYLE) {
                        proxy.push(
                          // ignore atomic tags (e.g., style): they have no "structural" effect
                          tok.type === "atomicTag" ? "" : "<" + tok.tagName + " " + BASEATTR + "proxyof=" + id + (tok.unary ? " />" : ">")
                        );
                      }
                    }
                  } else {
                    actual.push(tokenRaw);
                    proxy.push(tok.type === "endTag" ? tokenRaw : "");
                  }
                }
                return {
                  tokens,
                  raw: raw.join(""),
                  actual: actual.join(""),
                  proxy: proxy.join("")
                };
              };
              WriteStream2.prototype._walkChunk = function _walkChunk() {
                var node = void 0;
                var stack = [this.proxyRoot];
                while (utils.existy(node = stack.shift())) {
                  var isElement = node.nodeType === 1;
                  var isProxy = isElement && getData(node, "proxyof");
                  if (!isProxy) {
                    if (isElement) {
                      this.actuals[getData(node, "id")] = node;
                      setData(node, "id");
                    }
                    var parentIsProxyOf = node.parentNode && getData(node.parentNode, "proxyof");
                    if (parentIsProxyOf) {
                      this.actuals[parentIsProxyOf].appendChild(node);
                    }
                  }
                  stack.unshift.apply(stack, utils.toArray(node.childNodes));
                }
              };
              WriteStream2.prototype._handleScriptToken = function _handleScriptToken(tok) {
                var _this = this;
                var remainder = this.parser.clear();
                if (remainder) {
                  this.writeQueue.unshift(remainder);
                }
                tok.src = tok.attrs.src || tok.attrs.SRC;
                tok = this.options.beforeWriteToken(tok);
                if (!tok) {
                  return;
                }
                if (tok.src && this.scriptStack.length) {
                  this.deferredRemote = tok;
                } else {
                  this._onScriptStart(tok);
                }
                this._writeScriptToken(tok, function() {
                  _this._onScriptDone(tok);
                });
              };
              WriteStream2.prototype._handleStyleToken = function _handleStyleToken(tok) {
                var remainder = this.parser.clear();
                if (remainder) {
                  this.writeQueue.unshift(remainder);
                }
                tok.type = tok.attrs.type || tok.attrs.TYPE || "text/css";
                tok = this.options.beforeWriteToken(tok);
                if (tok) {
                  this._writeStyleToken(tok);
                }
                if (remainder) {
                  this.write();
                }
              };
              WriteStream2.prototype._writeStyleToken = function _writeStyleToken(tok) {
                var el = this._buildStyle(tok);
                this._insertCursor(el, PROXY_STYLE);
                if (tok.content) {
                  if (el.styleSheet && !el.sheet) {
                    el.styleSheet.cssText = tok.content;
                  } else {
                    el.appendChild(this.doc.createTextNode(tok.content));
                  }
                }
              };
              WriteStream2.prototype._buildStyle = function _buildStyle(tok) {
                var el = this.doc.createElement(tok.tagName);
                el.setAttribute("type", tok.type);
                utils.eachKey(tok.attrs, function(name, value) {
                  el.setAttribute(name, value);
                });
                return el;
              };
              WriteStream2.prototype._insertCursor = function _insertCursor(el, which) {
                this._writeImpl('<span id="' + which + '"/>');
                var cursor = this.doc.getElementById(which);
                if (cursor) {
                  cursor.parentNode.replaceChild(el, cursor);
                }
              };
              WriteStream2.prototype._onScriptStart = function _onScriptStart(tok) {
                tok.outerWrites = this.writeQueue;
                this.writeQueue = [];
                this.scriptStack.unshift(tok);
              };
              WriteStream2.prototype._onScriptDone = function _onScriptDone(tok) {
                if (tok !== this.scriptStack[0]) {
                  this.options.error({ msg: "Bad script nesting or script finished twice" });
                  return;
                }
                this.scriptStack.shift();
                this.write.apply(this, tok.outerWrites);
                if (!this.scriptStack.length && this.deferredRemote) {
                  this._onScriptStart(this.deferredRemote);
                  this.deferredRemote = null;
                }
              };
              WriteStream2.prototype._writeScriptToken = function _writeScriptToken(tok, done) {
                var el = this._buildScript(tok);
                var asyncRelease = this._shouldRelease(el);
                var afterAsync = this.options.afterAsync;
                if (tok.src) {
                  el.src = tok.src;
                  this._scriptLoadHandler(el, !asyncRelease ? function() {
                    done();
                    afterAsync();
                  } : afterAsync);
                }
                try {
                  this._insertCursor(el, PROXY_SCRIPT);
                  if (!el.src || asyncRelease) {
                    done();
                  }
                } catch (e) {
                  this.options.error(e);
                  done();
                }
              };
              WriteStream2.prototype._buildScript = function _buildScript(tok) {
                var el = this.doc.createElement(tok.tagName);
                utils.eachKey(tok.attrs, function(name, value) {
                  el.setAttribute(name, value);
                });
                if (tok.content) {
                  el.text = tok.content;
                }
                return el;
              };
              WriteStream2.prototype._scriptLoadHandler = function _scriptLoadHandler(el, done) {
                function cleanup() {
                  el = el.onload = el.onreadystatechange = el.onerror = null;
                }
                var error = this.options.error;
                function success() {
                  cleanup();
                  if (done != null) {
                    done();
                  }
                  done = null;
                }
                function failure(err) {
                  cleanup();
                  error(err);
                  if (done != null) {
                    done();
                  }
                  done = null;
                }
                function reattachEventListener(el2, evt) {
                  var handler = el2["on" + evt];
                  if (handler != null) {
                    el2["_on" + evt] = handler;
                  }
                }
                reattachEventListener(el, "load");
                reattachEventListener(el, "error");
                _extends(el, {
                  onload: function onload() {
                    if (el._onload) {
                      try {
                        el._onload.apply(this, Array.prototype.slice.call(arguments, 0));
                      } catch (err) {
                        failure({ msg: "onload handler failed " + err + " @ " + el.src });
                      }
                    }
                    success();
                  },
                  onerror: function onerror() {
                    if (el._onerror) {
                      try {
                        el._onerror.apply(this, Array.prototype.slice.call(arguments, 0));
                      } catch (err) {
                        failure({ msg: "onerror handler failed " + err + " @ " + el.src });
                        return;
                      }
                    }
                    failure({ msg: "remote script failed " + el.src });
                  },
                  onreadystatechange: function onreadystatechange() {
                    if (/^(loaded|complete)$/.test(el.readyState)) {
                      success();
                    }
                  }
                });
              };
              WriteStream2.prototype._shouldRelease = function _shouldRelease(el) {
                var isScript = /^script$/i.test(el.nodeName);
                return !isScript || !!(this.options.releaseAsync && el.src && el.hasAttribute("async"));
              };
              return WriteStream2;
            }();
            exports2["default"] = WriteStream;
          },
          /* 3 */
          /***/
          function(module2, exports2, __webpack_require__) {
            (function webpackUniversalModuleDefinition(root, factory) {
              if (true)
                module2.exports = factory();
              else if (typeof define === "function" && define.amd)
                define([], factory);
              else if (typeof exports2 === "object")
                exports2["Prescribe"] = factory();
              else
                root["Prescribe"] = factory();
            })(this, function() {
              return (
                /******/
                function(modules) {
                  var installedModules = {};
                  function __webpack_require__2(moduleId) {
                    if (installedModules[moduleId])
                      return installedModules[moduleId].exports;
                    var module3 = installedModules[moduleId] = {
                      /******/
                      exports: {},
                      /******/
                      id: moduleId,
                      /******/
                      loaded: false
                      /******/
                    };
                    modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__2);
                    module3.loaded = true;
                    return module3.exports;
                  }
                  __webpack_require__2.m = modules;
                  __webpack_require__2.c = installedModules;
                  __webpack_require__2.p = "";
                  return __webpack_require__2(0);
                }([
                  /* 0 */
                  /***/
                  function(module3, exports3, __webpack_require__2) {
                    "use strict";
                    var _HtmlParser = __webpack_require__2(1);
                    var _HtmlParser2 = _interopRequireDefault(_HtmlParser);
                    function _interopRequireDefault(obj) {
                      return obj && obj.__esModule ? obj : { "default": obj };
                    }
                    module3.exports = _HtmlParser2["default"];
                  },
                  /* 1 */
                  /***/
                  function(module3, exports3, __webpack_require__2) {
                    "use strict";
                    exports3.__esModule = true;
                    var _supports = __webpack_require__2(2);
                    var supports = _interopRequireWildcard(_supports);
                    var _streamReaders = __webpack_require__2(3);
                    var streamReaders = _interopRequireWildcard(_streamReaders);
                    var _fixedReadTokenFactory = __webpack_require__2(6);
                    var _fixedReadTokenFactory2 = _interopRequireDefault(_fixedReadTokenFactory);
                    var _utils = __webpack_require__2(5);
                    function _interopRequireDefault(obj) {
                      return obj && obj.__esModule ? obj : { "default": obj };
                    }
                    function _interopRequireWildcard(obj) {
                      if (obj && obj.__esModule) {
                        return obj;
                      } else {
                        var newObj = {};
                        if (obj != null) {
                          for (var key2 in obj) {
                            if (Object.prototype.hasOwnProperty.call(obj, key2))
                              newObj[key2] = obj[key2];
                          }
                        }
                        newObj["default"] = obj;
                        return newObj;
                      }
                    }
                    function _classCallCheck(instance, Constructor) {
                      if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                      }
                    }
                    var detect = {
                      comment: /^<!--/,
                      endTag: /^<\//,
                      atomicTag: /^<\s*(script|style|noscript|iframe|textarea)[\s\/>]/i,
                      startTag: /^</,
                      chars: /^[^<]/
                    };
                    var HtmlParser = function() {
                      function HtmlParser2() {
                        var _this = this;
                        var stream = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
                        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                        _classCallCheck(this, HtmlParser2);
                        this.stream = stream;
                        var fix = false;
                        var fixedTokenOptions = {};
                        for (var key2 in supports) {
                          if (supports.hasOwnProperty(key2)) {
                            if (options.autoFix) {
                              fixedTokenOptions[key2 + "Fix"] = true;
                            }
                            fix = fix || fixedTokenOptions[key2 + "Fix"];
                          }
                        }
                        if (fix) {
                          this._readToken = (0, _fixedReadTokenFactory2["default"])(this, fixedTokenOptions, function() {
                            return _this._readTokenImpl();
                          });
                          this._peekToken = (0, _fixedReadTokenFactory2["default"])(this, fixedTokenOptions, function() {
                            return _this._peekTokenImpl();
                          });
                        } else {
                          this._readToken = this._readTokenImpl;
                          this._peekToken = this._peekTokenImpl;
                        }
                      }
                      HtmlParser2.prototype.append = function append(str) {
                        this.stream += str;
                      };
                      HtmlParser2.prototype.prepend = function prepend(str) {
                        this.stream = str + this.stream;
                      };
                      HtmlParser2.prototype._readTokenImpl = function _readTokenImpl() {
                        var token = this._peekTokenImpl();
                        if (token) {
                          this.stream = this.stream.slice(token.length);
                          return token;
                        }
                      };
                      HtmlParser2.prototype._peekTokenImpl = function _peekTokenImpl() {
                        for (var type in detect) {
                          if (detect.hasOwnProperty(type)) {
                            if (detect[type].test(this.stream)) {
                              var token = streamReaders[type](this.stream);
                              if (token) {
                                if (token.type === "startTag" && /script|style/i.test(token.tagName)) {
                                  return null;
                                } else {
                                  token.text = this.stream.substr(0, token.length);
                                  return token;
                                }
                              }
                            }
                          }
                        }
                      };
                      HtmlParser2.prototype.peekToken = function peekToken() {
                        return this._peekToken();
                      };
                      HtmlParser2.prototype.readToken = function readToken() {
                        return this._readToken();
                      };
                      HtmlParser2.prototype.readTokens = function readTokens(handlers) {
                        var tok = void 0;
                        while (tok = this.readToken()) {
                          if (handlers[tok.type] && handlers[tok.type](tok) === false) {
                            return;
                          }
                        }
                      };
                      HtmlParser2.prototype.clear = function clear() {
                        var rest = this.stream;
                        this.stream = "";
                        return rest;
                      };
                      HtmlParser2.prototype.rest = function rest() {
                        return this.stream;
                      };
                      return HtmlParser2;
                    }();
                    exports3["default"] = HtmlParser;
                    HtmlParser.tokenToString = function(tok) {
                      return tok.toString();
                    };
                    HtmlParser.escapeAttributes = function(attrs) {
                      var escapedAttrs = {};
                      for (var name in attrs) {
                        if (attrs.hasOwnProperty(name)) {
                          escapedAttrs[name] = (0, _utils.escapeQuotes)(attrs[name], null);
                        }
                      }
                      return escapedAttrs;
                    };
                    HtmlParser.supports = supports;
                    for (var key in supports) {
                      if (supports.hasOwnProperty(key)) {
                        HtmlParser.browserHasFlaw = HtmlParser.browserHasFlaw || !supports[key] && key;
                      }
                    }
                  },
                  /* 2 */
                  /***/
                  function(module3, exports3) {
                    "use strict";
                    exports3.__esModule = true;
                    var tagSoup = false;
                    var selfClose = false;
                    var work = window.document.createElement("div");
                    try {
                      var html = "<P><I></P></I>";
                      work.innerHTML = html;
                      exports3.tagSoup = tagSoup = work.innerHTML !== html;
                    } catch (e) {
                      exports3.tagSoup = tagSoup = false;
                    }
                    try {
                      work.innerHTML = "<P><i><P></P></i></P>";
                      exports3.selfClose = selfClose = work.childNodes.length === 2;
                    } catch (e) {
                      exports3.selfClose = selfClose = false;
                    }
                    work = null;
                    exports3.tagSoup = tagSoup;
                    exports3.selfClose = selfClose;
                  },
                  /* 3 */
                  /***/
                  function(module3, exports3, __webpack_require__2) {
                    "use strict";
                    exports3.__esModule = true;
                    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
                      return typeof obj;
                    } : function(obj) {
                      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                    };
                    exports3.comment = comment;
                    exports3.chars = chars;
                    exports3.startTag = startTag;
                    exports3.atomicTag = atomicTag;
                    exports3.endTag = endTag;
                    var _tokens = __webpack_require__2(4);
                    var REGEXES = {
                      startTag: /^<([\-A-Za-z0-9_]+)((?:\s+[\w\-]+(?:\s*=?\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/,
                      endTag: /^<\/([\-A-Za-z0-9_]+)[^>]*>/,
                      attr: /(?:([\-A-Za-z0-9_]+)\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))|(?:([\-A-Za-z0-9_]+)(\s|$)+)/g,
                      fillAttr: /^(checked|compact|declare|defer|disabled|ismap|multiple|nohref|noresize|noshade|nowrap|readonly|selected)$/i
                    };
                    function comment(stream) {
                      var index = stream.indexOf("-->");
                      if (index >= 0) {
                        return new _tokens.CommentToken(stream.substr(4, index - 1), index + 3);
                      }
                    }
                    function chars(stream) {
                      var index = stream.indexOf("<");
                      return new _tokens.CharsToken(index >= 0 ? index : stream.length);
                    }
                    function startTag(stream) {
                      var endTagIndex = stream.indexOf(">");
                      if (endTagIndex !== -1) {
                        var match = stream.match(REGEXES.startTag);
                        if (match) {
                          var _ret = function() {
                            var attrs = {};
                            var booleanAttrs = {};
                            var rest = match[2];
                            match[2].replace(REGEXES.attr, function(match2, name) {
                              if (!(arguments[2] || arguments[3] || arguments[4] || arguments[5])) {
                                attrs[name] = "";
                              } else if (arguments[5]) {
                                attrs[arguments[5]] = "";
                                booleanAttrs[arguments[5]] = true;
                              } else {
                                attrs[name] = arguments[2] || arguments[3] || arguments[4] || REGEXES.fillAttr.test(name) && name || "";
                              }
                              rest = rest.replace(match2, "");
                            });
                            return {
                              v: new _tokens.StartTagToken(match[1], match[0].length, attrs, booleanAttrs, !!match[3], rest.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""))
                            };
                          }();
                          if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object")
                            return _ret.v;
                        }
                      }
                    }
                    function atomicTag(stream) {
                      var start = startTag(stream);
                      if (start) {
                        var rest = stream.slice(start.length);
                        if (rest.match(new RegExp("</\\s*" + start.tagName + "\\s*>", "i"))) {
                          var match = rest.match(new RegExp("([\\s\\S]*?)</\\s*" + start.tagName + "\\s*>", "i"));
                          if (match) {
                            return new _tokens.AtomicTagToken(start.tagName, match[0].length + start.length, start.attrs, start.booleanAttrs, match[1]);
                          }
                        }
                      }
                    }
                    function endTag(stream) {
                      var match = stream.match(REGEXES.endTag);
                      if (match) {
                        return new _tokens.EndTagToken(match[1], match[0].length);
                      }
                    }
                  },
                  /* 4 */
                  /***/
                  function(module3, exports3, __webpack_require__2) {
                    "use strict";
                    exports3.__esModule = true;
                    exports3.EndTagToken = exports3.AtomicTagToken = exports3.StartTagToken = exports3.TagToken = exports3.CharsToken = exports3.CommentToken = exports3.Token = void 0;
                    var _utils = __webpack_require__2(5);
                    function _classCallCheck(instance, Constructor) {
                      if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                      }
                    }
                    var Token = (
                      /**
                       * Constructor.
                       *
                       * @param {string} type The type of the Token.
                       * @param {Number} length The length of the Token text.
                       */
                      exports3.Token = function Token2(type, length) {
                        _classCallCheck(this, Token2);
                        this.type = type;
                        this.length = length;
                        this.text = "";
                      }
                    );
                    var CommentToken = exports3.CommentToken = function() {
                      function CommentToken2(content, length) {
                        _classCallCheck(this, CommentToken2);
                        this.type = "comment";
                        this.length = length || (content ? content.length : 0);
                        this.text = "";
                        this.content = content;
                      }
                      CommentToken2.prototype.toString = function toString() {
                        return "<!--" + this.content;
                      };
                      return CommentToken2;
                    }();
                    var CharsToken = exports3.CharsToken = function() {
                      function CharsToken2(length) {
                        _classCallCheck(this, CharsToken2);
                        this.type = "chars";
                        this.length = length;
                        this.text = "";
                      }
                      CharsToken2.prototype.toString = function toString() {
                        return this.text;
                      };
                      return CharsToken2;
                    }();
                    var TagToken = exports3.TagToken = function() {
                      function TagToken2(type, tagName, length, attrs, booleanAttrs) {
                        _classCallCheck(this, TagToken2);
                        this.type = type;
                        this.length = length;
                        this.text = "";
                        this.tagName = tagName;
                        this.attrs = attrs;
                        this.booleanAttrs = booleanAttrs;
                        this.unary = false;
                        this.html5Unary = false;
                      }
                      TagToken2.formatTag = function formatTag(tok) {
                        var content = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                        var str = "<" + tok.tagName;
                        for (var key in tok.attrs) {
                          if (tok.attrs.hasOwnProperty(key)) {
                            str += " " + key;
                            var val = tok.attrs[key];
                            if (typeof tok.booleanAttrs === "undefined" || typeof tok.booleanAttrs[key] === "undefined") {
                              str += '="' + (0, _utils.escapeQuotes)(val) + '"';
                            }
                          }
                        }
                        if (tok.rest) {
                          str += " " + tok.rest;
                        }
                        if (tok.unary && !tok.html5Unary) {
                          str += "/>";
                        } else {
                          str += ">";
                        }
                        if (content !== void 0 && content !== null) {
                          str += content + "</" + tok.tagName + ">";
                        }
                        return str;
                      };
                      return TagToken2;
                    }();
                    var StartTagToken = exports3.StartTagToken = function() {
                      function StartTagToken2(tagName, length, attrs, booleanAttrs, unary, rest) {
                        _classCallCheck(this, StartTagToken2);
                        this.type = "startTag";
                        this.length = length;
                        this.text = "";
                        this.tagName = tagName;
                        this.attrs = attrs;
                        this.booleanAttrs = booleanAttrs;
                        this.html5Unary = false;
                        this.unary = unary;
                        this.rest = rest;
                      }
                      StartTagToken2.prototype.toString = function toString() {
                        return TagToken.formatTag(this);
                      };
                      return StartTagToken2;
                    }();
                    var AtomicTagToken = exports3.AtomicTagToken = function() {
                      function AtomicTagToken2(tagName, length, attrs, booleanAttrs, content) {
                        _classCallCheck(this, AtomicTagToken2);
                        this.type = "atomicTag";
                        this.length = length;
                        this.text = "";
                        this.tagName = tagName;
                        this.attrs = attrs;
                        this.booleanAttrs = booleanAttrs;
                        this.unary = false;
                        this.html5Unary = false;
                        this.content = content;
                      }
                      AtomicTagToken2.prototype.toString = function toString() {
                        return TagToken.formatTag(this, this.content);
                      };
                      return AtomicTagToken2;
                    }();
                    var EndTagToken = exports3.EndTagToken = function() {
                      function EndTagToken2(tagName, length) {
                        _classCallCheck(this, EndTagToken2);
                        this.type = "endTag";
                        this.length = length;
                        this.text = "";
                        this.tagName = tagName;
                      }
                      EndTagToken2.prototype.toString = function toString() {
                        return "</" + this.tagName + ">";
                      };
                      return EndTagToken2;
                    }();
                  },
                  /* 5 */
                  /***/
                  function(module3, exports3) {
                    "use strict";
                    exports3.__esModule = true;
                    exports3.escapeQuotes = escapeQuotes;
                    function escapeQuotes(value) {
                      var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
                      return !value ? defaultValue : value.replace(/([^"]*)"/g, function(_, prefix) {
                        return /\\/.test(prefix) ? prefix + '"' : prefix + '\\"';
                      });
                    }
                  },
                  /* 6 */
                  /***/
                  function(module3, exports3) {
                    "use strict";
                    exports3.__esModule = true;
                    exports3["default"] = fixedReadTokenFactory;
                    var EMPTY = /^(AREA|BASE|BASEFONT|BR|COL|FRAME|HR|IMG|INPUT|ISINDEX|LINK|META|PARAM|EMBED)$/i;
                    var CLOSESELF = /^(COLGROUP|DD|DT|LI|OPTIONS|P|TD|TFOOT|TH|THEAD|TR)$/i;
                    function correct(tok) {
                      if (tok && tok.type === "startTag") {
                        tok.unary = EMPTY.test(tok.tagName) || tok.unary;
                        tok.html5Unary = !/\/>$/.test(tok.text);
                      }
                      return tok;
                    }
                    function peekToken(parser, readTokenImpl) {
                      var tmp = parser.stream;
                      var tok = correct(readTokenImpl());
                      parser.stream = tmp;
                      return tok;
                    }
                    function closeLast(parser, stack) {
                      var tok = stack.pop();
                      parser.prepend("</" + tok.tagName + ">");
                    }
                    function newStack() {
                      var stack = [];
                      stack.last = function() {
                        return this[this.length - 1];
                      };
                      stack.lastTagNameEq = function(tagName) {
                        var last = this.last();
                        return last && last.tagName && last.tagName.toUpperCase() === tagName.toUpperCase();
                      };
                      stack.containsTagName = function(tagName) {
                        for (var i = 0, tok; tok = this[i]; i++) {
                          if (tok.tagName === tagName) {
                            return true;
                          }
                        }
                        return false;
                      };
                      return stack;
                    }
                    function fixedReadTokenFactory(parser, options, readTokenImpl) {
                      var stack = newStack();
                      var handlers = {
                        startTag: function startTag(tok) {
                          var tagName = tok.tagName;
                          if (tagName.toUpperCase() === "TR" && stack.lastTagNameEq("TABLE")) {
                            parser.prepend("<TBODY>");
                            prepareNextToken();
                          } else if (options.selfCloseFix && CLOSESELF.test(tagName) && stack.containsTagName(tagName)) {
                            if (stack.lastTagNameEq(tagName)) {
                              closeLast(parser, stack);
                            } else {
                              parser.prepend("</" + tok.tagName + ">");
                              prepareNextToken();
                            }
                          } else if (!tok.unary) {
                            stack.push(tok);
                          }
                        },
                        endTag: function endTag(tok) {
                          var last = stack.last();
                          if (last) {
                            if (options.tagSoupFix && !stack.lastTagNameEq(tok.tagName)) {
                              closeLast(parser, stack);
                            } else {
                              stack.pop();
                            }
                          } else if (options.tagSoupFix) {
                            readTokenImpl();
                            prepareNextToken();
                          }
                        }
                      };
                      function prepareNextToken() {
                        var tok = peekToken(parser, readTokenImpl);
                        if (tok && handlers[tok.type]) {
                          handlers[tok.type](tok);
                        }
                      }
                      return function fixedReadToken() {
                        prepareNextToken();
                        return correct(readTokenImpl());
                      };
                    }
                  }
                  /******/
                ])
              );
            });
            ;
          },
          /* 4 */
          /***/
          function(module2, exports2) {
            "use strict";
            exports2.__esModule = true;
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports2.existy = existy;
            exports2.isFunction = isFunction;
            exports2.each = each;
            exports2.eachKey = eachKey;
            exports2.defaults = defaults;
            exports2.toArray = toArray;
            exports2.last = last;
            exports2.isTag = isTag;
            exports2.isScript = isScript;
            exports2.isStyle = isStyle;
            function existy(thing) {
              return thing !== void 0 && thing !== null;
            }
            function isFunction(x) {
              return "function" === typeof x;
            }
            function each(arr, fn, target) {
              var i = void 0;
              var len = arr && arr.length || 0;
              for (i = 0; i < len; i++) {
                fn.call(target, arr[i], i);
              }
            }
            function eachKey(obj, fn, target) {
              for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                  fn.call(target, key, obj[key]);
                }
              }
            }
            function defaults(options, _defaults) {
              options = options || {};
              eachKey(_defaults, function(key, val) {
                if (!existy(options[key])) {
                  options[key] = val;
                }
              });
              return options;
            }
            function toArray(obj) {
              try {
                return Array.prototype.slice.call(obj);
              } catch (e) {
                var _ret = function() {
                  var ret = [];
                  each(obj, function(val) {
                    ret.push(val);
                  });
                  return {
                    v: ret
                  };
                }();
                if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object")
                  return _ret.v;
              }
            }
            function last(array) {
              return array[array.length - 1];
            }
            function isTag(tok, tag) {
              return !tok || !(tok.type === "startTag" || tok.type === "atomicTag") || !("tagName" in tok) ? false : !!~tok.tagName.toLowerCase().indexOf(tag);
            }
            function isScript(tok) {
              return isTag(tok, "script");
            }
            function isStyle(tok) {
              return isTag(tok, "style");
            }
          }
          /******/
        ])
      );
    });
  }
});
export default require_postscribe();
/*! Bundled license information:

postscribe/dist/postscribe.js:
  (**
   * @file postscribe
   * @description Asynchronously write javascript, even with document.write.
   * @version v2.0.8
   * @see {@link https://krux.github.io/postscribe}
   * @license MIT
   * @author Derek Brans
   * @copyright 2016 Krux Digital, Inc
   *)
  (**
   * @file prescribe
   * @description Tiny, forgiving HTML parser
   * @version vundefined
   * @see {@link https://github.com/krux/prescribe/}
   * @license MIT
   * @author Derek Brans
   * @copyright 2016 Krux Digital, Inc
   *)
*/
//# sourceMappingURL=postscribe.js.map
