import "./chunk-LXYNHJXE.js";

// node_modules/delegate-it/delegate.js
var ledger = /* @__PURE__ */ new WeakMap();
function editLedger(wanted, baseElement, callback, setup) {
  if (!wanted && !ledger.has(baseElement)) {
    return false;
  }
  const elementMap = ledger.get(baseElement) ?? /* @__PURE__ */ new WeakMap();
  ledger.set(baseElement, elementMap);
  const setups = elementMap.get(callback) ?? /* @__PURE__ */ new Set();
  elementMap.set(callback, setups);
  const existed = setups.has(setup);
  if (wanted) {
    setups.add(setup);
  } else {
    setups.delete(setup);
  }
  return existed && wanted;
}
function safeClosest(event, selector) {
  let target = event.target;
  if (target instanceof Text) {
    target = target.parentElement;
  }
  if (target instanceof Element && event.currentTarget instanceof Element) {
    const closest = target.closest(selector);
    if (closest && event.currentTarget.contains(closest)) {
      return closest;
    }
  }
}
function delegate(selector, type, callback, options = {}) {
  const { signal, base = document } = options;
  if (signal == null ? void 0 : signal.aborted) {
    return;
  }
  const { once, ...nativeListenerOptions } = options;
  const baseElement = base instanceof Document ? base.documentElement : base;
  const capture = Boolean(typeof options === "object" ? options.capture : options);
  const listenerFn = (event) => {
    const delegateTarget = safeClosest(event, selector);
    if (delegateTarget) {
      const delegateEvent = Object.assign(event, { delegateTarget });
      callback.call(baseElement, delegateEvent);
      if (once) {
        baseElement.removeEventListener(type, listenerFn, nativeListenerOptions);
        editLedger(false, baseElement, callback, setup);
      }
    }
  };
  const setup = JSON.stringify({ selector, type, capture });
  const isAlreadyListening = editLedger(true, baseElement, callback, setup);
  if (!isAlreadyListening) {
    baseElement.addEventListener(type, listenerFn, nativeListenerOptions);
  }
  signal == null ? void 0 : signal.addEventListener("abort", () => {
    editLedger(false, baseElement, callback, setup);
  });
}
var delegate_default = delegate;

// node_modules/path-to-regexp/dist.es2015/index.js
function lexer(str) {
  var tokens = [];
  var i2 = 0;
  while (i2 < str.length) {
    var char = str[i2];
    if (char === "*" || char === "+" || char === "?") {
      tokens.push({ type: "MODIFIER", index: i2, value: str[i2++] });
      continue;
    }
    if (char === "\\") {
      tokens.push({ type: "ESCAPED_CHAR", index: i2++, value: str[i2++] });
      continue;
    }
    if (char === "{") {
      tokens.push({ type: "OPEN", index: i2, value: str[i2++] });
      continue;
    }
    if (char === "}") {
      tokens.push({ type: "CLOSE", index: i2, value: str[i2++] });
      continue;
    }
    if (char === ":") {
      var name = "";
      var j = i2 + 1;
      while (j < str.length) {
        var code = str.charCodeAt(j);
        if (
          // `0-9`
          code >= 48 && code <= 57 || // `A-Z`
          code >= 65 && code <= 90 || // `a-z`
          code >= 97 && code <= 122 || // `_`
          code === 95
        ) {
          name += str[j++];
          continue;
        }
        break;
      }
      if (!name)
        throw new TypeError("Missing parameter name at ".concat(i2));
      tokens.push({ type: "NAME", index: i2, value: name });
      i2 = j;
      continue;
    }
    if (char === "(") {
      var count = 1;
      var pattern = "";
      var j = i2 + 1;
      if (str[j] === "?") {
        throw new TypeError('Pattern cannot start with "?" at '.concat(j));
      }
      while (j < str.length) {
        if (str[j] === "\\") {
          pattern += str[j++] + str[j++];
          continue;
        }
        if (str[j] === ")") {
          count--;
          if (count === 0) {
            j++;
            break;
          }
        } else if (str[j] === "(") {
          count++;
          if (str[j + 1] !== "?") {
            throw new TypeError("Capturing groups are not allowed at ".concat(j));
          }
        }
        pattern += str[j++];
      }
      if (count)
        throw new TypeError("Unbalanced pattern at ".concat(i2));
      if (!pattern)
        throw new TypeError("Missing pattern at ".concat(i2));
      tokens.push({ type: "PATTERN", index: i2, value: pattern });
      i2 = j;
      continue;
    }
    tokens.push({ type: "CHAR", index: i2, value: str[i2++] });
  }
  tokens.push({ type: "END", index: i2, value: "" });
  return tokens;
}
function parse(str, options) {
  if (options === void 0) {
    options = {};
  }
  var tokens = lexer(str);
  var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
  var defaultPattern = "[^".concat(escapeString(options.delimiter || "/#?"), "]+?");
  var result = [];
  var key = 0;
  var i2 = 0;
  var path = "";
  var tryConsume = function(type) {
    if (i2 < tokens.length && tokens[i2].type === type)
      return tokens[i2++].value;
  };
  var mustConsume = function(type) {
    var value2 = tryConsume(type);
    if (value2 !== void 0)
      return value2;
    var _a2 = tokens[i2], nextType = _a2.type, index = _a2.index;
    throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type));
  };
  var consumeText = function() {
    var result2 = "";
    var value2;
    while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
      result2 += value2;
    }
    return result2;
  };
  while (i2 < tokens.length) {
    var char = tryConsume("CHAR");
    var name = tryConsume("NAME");
    var pattern = tryConsume("PATTERN");
    if (name || pattern) {
      var prefix = char || "";
      if (prefixes.indexOf(prefix) === -1) {
        path += prefix;
        prefix = "";
      }
      if (path) {
        result.push(path);
        path = "";
      }
      result.push({
        name: name || key++,
        prefix,
        suffix: "",
        pattern: pattern || defaultPattern,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    var value = char || tryConsume("ESCAPED_CHAR");
    if (value) {
      path += value;
      continue;
    }
    if (path) {
      result.push(path);
      path = "";
    }
    var open = tryConsume("OPEN");
    if (open) {
      var prefix = consumeText();
      var name_1 = tryConsume("NAME") || "";
      var pattern_1 = tryConsume("PATTERN") || "";
      var suffix = consumeText();
      mustConsume("CLOSE");
      result.push({
        name: name_1 || (pattern_1 ? key++ : ""),
        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
        prefix,
        suffix,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    mustConsume("END");
  }
  return result;
}
function match(str, options) {
  var keys = [];
  var re = pathToRegexp(str, keys, options);
  return regexpToFunction(re, keys, options);
}
function regexpToFunction(re, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.decode, decode = _a === void 0 ? function(x2) {
    return x2;
  } : _a;
  return function(pathname) {
    var m2 = re.exec(pathname);
    if (!m2)
      return false;
    var path = m2[0], index = m2.index;
    var params = /* @__PURE__ */ Object.create(null);
    var _loop_1 = function(i3) {
      if (m2[i3] === void 0)
        return "continue";
      var key = keys[i3 - 1];
      if (key.modifier === "*" || key.modifier === "+") {
        params[key.name] = m2[i3].split(key.prefix + key.suffix).map(function(value) {
          return decode(value, key);
        });
      } else {
        params[key.name] = decode(m2[i3], key);
      }
    };
    for (var i2 = 1; i2 < m2.length; i2++) {
      _loop_1(i2);
    }
    return { path, index, params };
  };
}
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
function regexpToRegexp(path, keys) {
  if (!keys)
    return path;
  var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
  var index = 0;
  var execResult = groupsRegex.exec(path.source);
  while (execResult) {
    keys.push({
      // Use parenthesized substring match if available, index otherwise
      name: execResult[1] || index++,
      prefix: "",
      suffix: "",
      modifier: "",
      pattern: ""
    });
    execResult = groupsRegex.exec(path.source);
  }
  return path;
}
function arrayToRegexp(paths, keys, options) {
  var parts = paths.map(function(path) {
    return pathToRegexp(path, keys, options).source;
  });
  return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options));
}
function stringToRegexp(path, keys, options) {
  return tokensToRegexp(parse(path, options), keys, options);
}
function tokensToRegexp(tokens, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function(x2) {
    return x2;
  } : _d, _e = options.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options.endsWith, endsWith = _f === void 0 ? "" : _f;
  var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
  var delimiterRe = "[".concat(escapeString(delimiter), "]");
  var route = start ? "^" : "";
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    if (typeof token === "string") {
      route += escapeString(encode(token));
    } else {
      var prefix = escapeString(encode(token.prefix));
      var suffix = escapeString(encode(token.suffix));
      if (token.pattern) {
        if (keys)
          keys.push(token);
        if (prefix || suffix) {
          if (token.modifier === "+" || token.modifier === "*") {
            var mod = token.modifier === "*" ? "?" : "";
            route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod);
          } else {
            route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);
          }
        } else {
          if (token.modifier === "+" || token.modifier === "*") {
            route += "((?:".concat(token.pattern, ")").concat(token.modifier, ")");
          } else {
            route += "(".concat(token.pattern, ")").concat(token.modifier);
          }
        }
      } else {
        route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);
      }
    }
  }
  if (end) {
    if (!strict)
      route += "".concat(delimiterRe, "?");
    route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
  } else {
    var endToken = tokens[tokens.length - 1];
    var isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
    if (!strict) {
      route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
    }
    if (!isEndDelimited) {
      route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
    }
  }
  return new RegExp(route, flags(options));
}
function pathToRegexp(path, keys, options) {
  if (path instanceof RegExp)
    return regexpToRegexp(path, keys);
  if (Array.isArray(path))
    return arrayToRegexp(path, keys, options);
  return stringToRegexp(path, keys, options);
}

// node_modules/swup/dist/Swup.modern.js
function i() {
  return i = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var i2 = arguments[e];
      for (var s2 in i2)
        Object.prototype.hasOwnProperty.call(i2, s2) && (t[s2] = i2[s2]);
    }
    return t;
  }, i.apply(this, arguments);
}
var s = (t, e) => String(t).toLowerCase().replace(/[\s/_.]+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+|-+$/g, "") || e || "";
var n = ({ hash: t } = {}) => location.pathname + location.search + (t ? location.hash : "");
var o = (t, e = {}) => {
  const s2 = i({ url: t = t || n({ hash: true }), random: Math.random(), source: "swup" }, e);
  history.pushState(s2, "", t);
};
var r = (t = null, e = {}) => {
  t = t || n({ hash: true });
  const s2 = i({}, history.state || {}, { url: t, random: Math.random(), source: "swup" }, e);
  history.replaceState(s2, "", t);
};
var a = (e, s2, n2, o2) => {
  const r2 = new AbortController();
  return o2 = i({}, o2, { signal: r2.signal }), delegate_default(e, s2, n2, o2), { destroy: () => r2.abort() };
};
var l = class _l extends URL {
  constructor(t, e = document.baseURI) {
    super(t.toString(), e);
  }
  get url() {
    return this.pathname + this.search;
  }
  static fromElement(t) {
    const e = t.getAttribute("href") || t.getAttribute("xlink:href") || "";
    return new _l(e);
  }
  static fromUrl(t) {
    return new _l(t);
  }
};
var h = (t, i2) => {
  try {
    return match(t, i2);
  } catch (e) {
    throw new Error(`[swup] Error parsing path "${String(t)}":
${String(e)}`);
  }
};
var c = class extends Error {
  constructor(t, e) {
    super(t), this.url = void 0, this.status = void 0, this.aborted = void 0, this.timedOut = void 0, this.name = "FetchError", this.url = e.url, this.status = e.status, this.aborted = e.aborted || false, this.timedOut = e.timedOut || false;
  }
};
async function u(t, e = {}) {
  var s2;
  t = l.fromUrl(t).url;
  const n2 = i({}, this.options.requestHeaders, e.headers), o2 = null != (s2 = e.timeout) ? s2 : this.options.timeout, r2 = new AbortController(), { signal: a2 } = r2;
  e = i({}, e, { headers: n2, signal: a2 });
  let h2, u2 = false, d2 = null;
  o2 && o2 > 0 && (d2 = setTimeout(() => {
    u2 = true, r2.abort("timeout");
  }, o2));
  try {
    h2 = await this.hooks.call("fetch:request", { url: t, options: e }, (t2, { url: e2, options: i2 }) => fetch(e2, i2)), d2 && clearTimeout(d2);
  } catch (e2) {
    if (u2)
      throw this.hooks.call("fetch:timeout", { url: t }), new c(`Request timed out: ${t}`, { url: t, timedOut: u2 });
    if ("AbortError" === (null == e2 ? void 0 : e2.name) || a2.aborted)
      throw new c(`Request aborted: ${t}`, { url: t, aborted: true });
    throw e2;
  }
  const { status: p2, url: m2 } = h2, g2 = await h2.text();
  if (500 === p2)
    throw this.hooks.call("fetch:error", { status: p2, response: h2, url: m2 }), new c(`Server error: ${m2}`, { status: p2, url: m2 });
  if (!g2)
    throw new c(`Empty response: ${m2}`, { status: p2, url: m2 });
  const { url: f2 } = l.fromUrl(m2), w2 = { url: f2, html: g2 };
  return !this.visit.cache.write || e.method && "GET" !== e.method || t !== f2 || this.cache.set(w2.url, w2), w2;
}
var d = class {
  constructor(t) {
    this.swup = void 0, this.pages = /* @__PURE__ */ new Map(), this.swup = t;
  }
  get size() {
    return this.pages.size;
  }
  get all() {
    const t = /* @__PURE__ */ new Map();
    return this.pages.forEach((e, s2) => {
      t.set(s2, i({}, e));
    }), t;
  }
  has(t) {
    return this.pages.has(this.resolve(t));
  }
  get(t) {
    const e = this.pages.get(this.resolve(t));
    return e ? i({}, e) : e;
  }
  set(t, e) {
    e = i({}, e, { url: t = this.resolve(t) }), this.pages.set(t, e), this.swup.hooks.callSync("cache:set", { page: e });
  }
  update(t, e) {
    t = this.resolve(t);
    const s2 = i({}, this.get(t), e, { url: t });
    this.pages.set(t, s2);
  }
  delete(t) {
    this.pages.delete(this.resolve(t));
  }
  clear() {
    this.pages.clear(), this.swup.hooks.callSync("cache:clear", void 0);
  }
  prune(t) {
    this.pages.forEach((e, i2) => {
      t(i2, e) && this.delete(i2);
    });
  }
  resolve(t) {
    const { url: e } = l.fromUrl(t);
    return this.swup.resolveUrl(e);
  }
};
var p = (t, e = document) => e.querySelector(t);
var m = (t, e = document) => Array.from(e.querySelectorAll(t));
var g = () => new Promise((t) => {
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      t();
    });
  });
});
function f(t) {
  return !!t && ("object" == typeof t || "function" == typeof t) && "function" == typeof t.then;
}
function w(t, e = []) {
  return new Promise((i2, s2) => {
    const n2 = t(...e);
    f(n2) ? n2.then(i2, s2) : i2(n2);
  });
}
function v(t) {
  var e;
  return null == (e = t = t || document.body) ? void 0 : e.offsetHeight;
}
var y = (t) => window.CSS && window.CSS.escape ? CSS.escape(t) : t;
var k = (t) => 1e3 * Number(t.slice(0, -1).replace(",", "."));
var S = class {
  constructor(t) {
    this.swup = void 0, this.swupClasses = ["to-", "is-changing", "is-rendering", "is-popstate", "is-animating"], this.swup = t;
  }
  get selectors() {
    const { scope: t } = this.swup.visit.animation;
    return "containers" === t ? this.swup.visit.containers : "html" === t ? ["html"] : Array.isArray(t) ? t : [];
  }
  get selector() {
    return this.selectors.join(",");
  }
  get targets() {
    return this.selector.trim() ? m(this.selector) : [];
  }
  add(...t) {
    this.targets.forEach((e) => e.classList.add(...t));
  }
  remove(...t) {
    this.targets.forEach((e) => e.classList.remove(...t));
  }
  clear() {
    this.targets.forEach((t) => {
      const e = t.className.split(" ").filter((t2) => this.isSwupClass(t2));
      t.classList.remove(...e);
    });
  }
  isSwupClass(t) {
    return this.swupClasses.some((e) => t.startsWith(e));
  }
};
function b({ to: t, from: e = this.currentPageUrl, hash: i2, el: s2, event: n2 }) {
  return { id: Math.random(), from: { url: e }, to: { url: t, hash: i2 }, containers: this.options.containers, animation: { animate: true, wait: false, name: void 0, scope: this.options.animationScope, selector: this.options.animationSelector }, trigger: { el: s2, event: n2 }, cache: { read: this.options.cache, write: this.options.cache }, history: { action: "push", popstate: false, direction: void 0 }, scroll: { reset: true, target: void 0 } };
}
var E = class {
  constructor(t) {
    this.swup = void 0, this.registry = /* @__PURE__ */ new Map(), this.hooks = ["animation:out:start", "animation:out:await", "animation:out:end", "animation:in:start", "animation:in:await", "animation:in:end", "animation:skip", "cache:clear", "cache:set", "content:replace", "content:scroll", "enable", "disable", "fetch:request", "fetch:error", "fetch:timeout", "history:popstate", "link:click", "link:self", "link:anchor", "link:newtab", "page:load", "page:view", "scroll:top", "scroll:anchor", "visit:start", "visit:transition", "visit:end"], this.swup = t, this.init();
  }
  init() {
    this.hooks.forEach((t) => this.create(t));
  }
  create(t) {
    this.registry.has(t) || this.registry.set(t, /* @__PURE__ */ new Map());
  }
  exists(t) {
    return this.registry.has(t);
  }
  get(t) {
    const e = this.registry.get(t);
    if (e)
      return e;
    console.error(`Unknown hook '${t}'`);
  }
  clear() {
    this.registry.forEach((t) => t.clear());
  }
  on(t, e, s2 = {}) {
    const n2 = this.get(t);
    if (!n2)
      return console.warn(`Hook '${t}' not found.`), () => {
      };
    const o2 = i({}, s2, { id: n2.size + 1, hook: t, handler: e });
    return n2.set(e, o2), () => this.off(t, e);
  }
  before(t, e, s2 = {}) {
    return this.on(t, e, i({}, s2, { before: true }));
  }
  replace(t, e, s2 = {}) {
    return this.on(t, e, i({}, s2, { replace: true }));
  }
  once(t, e, s2 = {}) {
    return this.on(t, e, i({}, s2, { once: true }));
  }
  off(t, e) {
    const i2 = this.get(t);
    i2 && e ? i2.delete(e) || console.warn(`Handler for hook '${t}' not found.`) : i2 && i2.clear();
  }
  async call(t, e, i2) {
    const { before: s2, handler: n2, after: o2 } = this.getHandlers(t, i2);
    await this.run(s2, e);
    const [r2] = await this.run(n2, e);
    return await this.run(o2, e), this.dispatchDomEvent(t, e), r2;
  }
  callSync(t, e, i2) {
    const { before: s2, handler: n2, after: o2 } = this.getHandlers(t, i2);
    this.runSync(s2, e);
    const [r2] = this.runSync(n2, e);
    return this.runSync(o2, e), this.dispatchDomEvent(t, e), r2;
  }
  async run(t, e) {
    const i2 = [];
    for (const { hook: s2, handler: n2, defaultHandler: o2, once: r2 } of t) {
      const t2 = await w(n2, [this.swup.visit, e, o2]);
      i2.push(t2), r2 && this.off(s2, n2);
    }
    return i2;
  }
  runSync(t, e) {
    const i2 = [];
    for (const { hook: s2, handler: n2, defaultHandler: o2, once: r2 } of t) {
      const t2 = n2(this.swup.visit, e, o2);
      i2.push(t2), f(t2) && console.warn(`Promise returned from handler for synchronous hook '${s2}'.Swup will not wait for it to resolve.`), r2 && this.off(s2, n2);
    }
    return i2;
  }
  getHandlers(t, e) {
    const i2 = this.get(t);
    if (!i2)
      return { found: false, before: [], handler: [], after: [], replaced: false };
    const s2 = Array.from(i2.values()), n2 = this.sortRegistrations, o2 = s2.filter(({ before: t2, replace: e2 }) => t2 && !e2).sort(n2), r2 = s2.filter(({ replace: t2 }) => t2).filter((t2) => true).sort(n2), a2 = s2.filter(({ before: t2, replace: e2 }) => !t2 && !e2).sort(n2), l2 = r2.length > 0;
    let h2 = [];
    if (e && (h2 = [{ id: 0, hook: t, handler: e }], l2)) {
      const i3 = r2.length - 1, s3 = (t2) => {
        const i4 = r2[t2 - 1];
        return i4 ? (e2, n3) => i4.handler(e2, n3, s3(t2 - 1)) : e;
      };
      h2 = [{ id: 0, hook: t, handler: r2[i3].handler, defaultHandler: s3(i3) }];
    }
    return { found: true, before: o2, handler: h2, after: a2, replaced: l2 };
  }
  sortRegistrations(t, e) {
    var i2, s2;
    return (null != (i2 = t.priority) ? i2 : 0) - (null != (s2 = e.priority) ? s2 : 0) || t.id - e.id || 0;
  }
  dispatchDomEvent(t, e) {
    document.dispatchEvent(new CustomEvent(`swup:${t}`, { detail: { hook: t, args: e, visit: this.swup.visit } }));
  }
};
var P = (t) => {
  if (t && "#" === t.charAt(0) && (t = t.substring(1)), !t)
    return null;
  const e = decodeURIComponent(t);
  let i2 = document.getElementById(t) || document.getElementById(e) || p(`a[name='${y(t)}']`) || p(`a[name='${y(e)}']`);
  return i2 || "top" !== t || (i2 = document.body), i2;
};
var U = "transition";
var C = "animation";
async function $({ elements: t, selector: e }) {
  if (false === e && !t)
    return;
  let i2 = [];
  if (t)
    i2 = Array.from(t);
  else if (e && (i2 = m(e, document.body), !i2.length))
    return void console.warn(`[swup] No elements found matching animationSelector \`${e}\``);
  const s2 = i2.map((t2) => function(t3) {
    const { type: e2, timeout: i3, propCount: s3 } = function(t4, e3) {
      const i4 = window.getComputedStyle(t4), s4 = x(i4, `${U}Delay`), n2 = x(i4, `${U}Duration`), o2 = H(s4, n2), r2 = x(i4, `${C}Delay`), a2 = x(i4, `${C}Duration`), l2 = H(r2, a2);
      let h2 = null, c2 = 0, u2 = 0;
      return c2 = Math.max(o2, l2), h2 = c2 > 0 ? o2 > l2 ? U : C : null, u2 = h2 ? h2 === U ? n2.length : a2.length : 0, { type: h2, timeout: c2, propCount: u2 };
    }(t3);
    return !(!e2 || !i3) && new Promise((n2) => {
      const o2 = `${e2}end`, r2 = performance.now();
      let a2 = 0;
      const l2 = () => {
        t3.removeEventListener(o2, h2), n2();
      }, h2 = (e3) => {
        if (e3.target === t3) {
          if (!function(t4) {
            return [`${U}end`, `${C}end`].includes(t4.type);
          }(e3))
            throw new Error("Not a transition or animation event.");
          (performance.now() - r2) / 1e3 < e3.elapsedTime || ++a2 >= s3 && l2();
        }
      };
      setTimeout(() => {
        a2 < s3 && l2();
      }, i3 + 1), t3.addEventListener(o2, h2);
    });
  }(t2));
  s2.filter(Boolean).length > 0 ? await Promise.all(s2) : e && console.warn(`[swup] No CSS animation duration defined on elements matching \`${e}\``);
}
function x(t, e) {
  return (t[e] || "").split(", ");
}
function H(t, e) {
  for (; t.length < e.length; )
    t = t.concat(t);
  return Math.max(...e.map((e2, i2) => k(e2) + k(t[i2])));
}
function A(t, e = {}, s2 = {}) {
  if ("string" != typeof t)
    throw new Error("swup.navigate() requires a URL parameter");
  if (this.shouldIgnoreVisit(t, { el: s2.el, event: s2.event }))
    return void (window.location.href = t);
  const { url: n2, hash: o2 } = l.fromUrl(t);
  this.visit = this.createVisit(i({}, s2, { to: n2, hash: o2 })), this.performNavigation(e);
}
async function q(t = {}) {
  this.navigating = true;
  const e = this.visit, { el: i2 } = e.trigger;
  t.referrer = t.referrer || this.currentPageUrl, false === t.animate && (e.animation.animate = false), e.animation.animate || this.classes.clear();
  const s2 = t.history || (null == i2 ? void 0 : i2.getAttribute("data-swup-history")) || void 0;
  s2 && ["push", "replace"].includes(s2) && (e.history.action = s2);
  const a2 = t.animation || (null == i2 ? void 0 : i2.getAttribute("data-swup-animation")) || void 0;
  var l2, h2;
  a2 && (e.animation.name = a2), "object" == typeof t.cache ? (e.cache.read = null != (l2 = t.cache.read) ? l2 : e.cache.read, e.cache.write = null != (h2 = t.cache.write) ? h2 : e.cache.write) : void 0 !== t.cache && (e.cache = { read: !!t.cache, write: !!t.cache }), delete t.cache;
  try {
    await this.hooks.call("visit:start", void 0);
    const i3 = this.hooks.call("page:load", { options: t }, async (t2, e2) => {
      let i4;
      return t2.cache.read && (i4 = this.cache.get(t2.to.url)), e2.page = i4 || await this.fetchPage(t2.to.url, e2.options), e2.cache = !!i4, e2.page;
    });
    if (!e.history.popstate) {
      const t2 = e.to.url + e.to.hash;
      "replace" === e.history.action || e.to.url === this.currentPageUrl ? r(t2) : (this.currentHistoryIndex++, o(t2, { index: this.currentHistoryIndex }));
    }
    if (this.currentPageUrl = n(), e.animation.wait) {
      const { html: t2 } = await i3;
      e.to.html = t2;
    }
    await this.hooks.call("visit:transition", void 0, async (t2) => {
      const e2 = this.animatePageOut(), [s3] = await Promise.all([i3, e2]);
      return t2.id === this.visit.id && (await this.renderPage(s3), await this.animatePageIn(), true);
    }), await this.hooks.call("visit:end", void 0, () => this.classes.clear()), this.navigating = false;
  } catch (t2) {
    if (!t2 || null != t2 && t2.aborted)
      return;
    console.error(t2), this.options.skipPopStateHandling = () => (window.location.href = e.to.url + e.to.hash, true), window.history.go(-1);
  }
}
var I = async function() {
  this.visit.animation.animate ? (await this.hooks.call("animation:out:start", void 0, (t) => {
    this.classes.add("is-changing", "is-leaving", "is-animating"), t.history.popstate && this.classes.add("is-popstate"), t.animation.name && this.classes.add(`to-${s(t.animation.name)}`);
  }), await this.hooks.call("animation:out:await", { skip: false }, async (t, { skip: e }) => {
    e || await this.awaitAnimations({ selector: t.animation.selector });
  }), await this.hooks.call("animation:out:end", void 0)) : await this.hooks.call("animation:skip", void 0);
};
var R = function({ html: t }, { containers: e } = this.options) {
  var i2;
  const s2 = new DOMParser().parseFromString(t, "text/html"), n2 = (null == (i2 = s2.querySelector("title")) ? void 0 : i2.innerText) || "";
  document.title = n2;
  const o2 = m('[data-swup-persist]:not([data-swup-persist=""])'), r2 = e.map((t2) => {
    const e2 = document.querySelector(t2), i3 = s2.querySelector(t2);
    return e2 && i3 ? (e2.replaceWith(i3), true) : (e2 || console.warn(`[swup] Container missing in current document: ${t2}`), i3 || console.warn(`[swup] Container missing in incoming document: ${t2}`), false);
  }).filter(Boolean);
  return o2.forEach((t2) => {
    const e2 = t2.getAttribute("data-swup-persist"), i3 = p(`[data-swup-persist="${e2}"]`);
    i3 && i3 !== t2 && i3.replaceWith(t2);
  }), r2.length === e.length;
};
var L = function() {
  const t = { behavior: "auto" }, { target: e, reset: s2 } = this.visit.scroll, n2 = null != e ? e : this.visit.to.hash;
  let o2 = false;
  return n2 && (o2 = this.hooks.callSync("scroll:anchor", { hash: n2, options: t }, (t2, { hash: e2, options: i2 }) => {
    const s3 = this.getAnchorElement(e2);
    return s3 && s3.scrollIntoView(i2), !!s3;
  })), s2 && !o2 && (o2 = this.hooks.callSync("scroll:top", { options: t }, (t2, { options: e2 }) => (window.scrollTo(i({ top: 0, left: 0 }, e2)), true))), o2;
};
var N = async function() {
  if (!this.visit.animation.animate)
    return;
  const t = this.hooks.call("animation:in:await", { skip: false }, async (t2, { skip: e }) => {
    e || await this.awaitAnimations({ selector: t2.animation.selector });
  });
  await g(), await this.hooks.call("animation:in:start", void 0, () => {
    this.classes.remove("is-animating");
  }), await t, await this.hooks.call("animation:in:end", void 0);
};
var T = async function(t) {
  const { url: e, html: i2 } = t;
  this.classes.remove("is-leaving"), this.isSameResolvedUrl(n(), e) || (r(e), this.currentPageUrl = n(), this.visit.to.url = this.currentPageUrl), this.visit.animation.animate && this.classes.add("is-rendering"), this.visit.to.html = i2, await this.hooks.call("content:replace", { page: t }, (t2, { page: e2 }) => {
    if (!this.replaceContent(e2, { containers: t2.containers }))
      throw new Error("[swup] Container mismatch, aborting");
    t2.animation.animate && (this.classes.add("is-animating", "is-changing", "is-rendering"), t2.animation.name && this.classes.add(`to-${s(t2.animation.name)}`));
  }), await this.hooks.call("content:scroll", void 0, () => this.scrollToContent()), await this.hooks.call("page:view", { url: this.currentPageUrl, title: document.title });
};
var D = function(t) {
  var e;
  if (e = t, Boolean(null == e ? void 0 : e.isSwupPlugin)) {
    if (t.swup = this, !t._checkRequirements || t._checkRequirements())
      return t._beforeMount && t._beforeMount(), t.mount(), this.plugins.push(t), this.plugins;
  } else
    console.error("Not a swup plugin instance", t);
};
function O(t) {
  const e = this.findPlugin(t);
  if (e)
    return e.unmount(), e._afterUnmount && e._afterUnmount(), this.plugins = this.plugins.filter((t2) => t2 !== e), this.plugins;
  console.error("No such plugin", e);
}
function M(t) {
  return this.plugins.find((e) => e === t || e.name === t || e.name === `Swup${String(t)}`);
}
function V(t) {
  if ("function" != typeof this.options.resolveUrl)
    return console.warn("[swup] options.resolveUrl expects a callback function."), t;
  const e = this.options.resolveUrl(t);
  return e && "string" == typeof e ? e.startsWith("//") || e.startsWith("http") ? (console.warn("[swup] options.resolveUrl needs to return a relative url"), t) : e : (console.warn("[swup] options.resolveUrl needs to return a url"), t);
}
function W(t, e) {
  return this.resolveUrl(t) === this.resolveUrl(e);
}
var B = { animateHistoryBrowsing: false, animationSelector: '[class*="transition-"]', animationScope: "html", cache: true, containers: ["#swup"], ignoreVisit: (t, { el: e } = {}) => !(null == e || !e.closest("[data-no-swup]")), linkSelector: "a[href]", linkToSelf: "scroll", plugins: [], resolveUrl: (t) => t, requestHeaders: { "X-Requested-With": "swup", Accept: "text/html, application/xhtml+xml" }, skipPopStateHandling: (t) => {
  var e;
  return "swup" !== (null == (e = t.state) ? void 0 : e.source);
}, timeout: 0 };
var _ = class {
  constructor(t = {}) {
    var e, s2;
    this.version = "4.4.2", this.options = void 0, this.defaults = B, this.plugins = [], this.visit = void 0, this.cache = void 0, this.hooks = void 0, this.classes = void 0, this.currentPageUrl = n(), this.currentHistoryIndex = void 0, this.clickDelegate = void 0, this.navigating = false, this.use = D, this.unuse = O, this.findPlugin = M, this.log = () => {
    }, this.navigate = A, this.performNavigation = q, this.createVisit = b, this.delegateEvent = a, this.fetchPage = u, this.awaitAnimations = $, this.renderPage = T, this.replaceContent = R, this.animatePageIn = N, this.animatePageOut = I, this.scrollToContent = L, this.getAnchorElement = P, this.getCurrentUrl = n, this.resolveUrl = V, this.isSameResolvedUrl = W, this.options = i({}, this.defaults, t), this.handleLinkClick = this.handleLinkClick.bind(this), this.handlePopState = this.handlePopState.bind(this), this.cache = new d(this), this.classes = new S(this), this.hooks = new E(this), this.visit = this.createVisit({ to: "" }), this.currentHistoryIndex = null != (e = null == (s2 = history.state) ? void 0 : s2.index) ? e : 1, this.checkRequirements() && this.enable();
  }
  checkRequirements() {
    return "undefined" != typeof Promise || (console.warn("Promise is not supported"), false);
  }
  async enable() {
    var t;
    const { linkSelector: e } = this.options;
    this.clickDelegate = this.delegateEvent(e, "click", this.handleLinkClick), window.addEventListener("popstate", this.handlePopState), this.options.animateHistoryBrowsing && (window.history.scrollRestoration = "manual"), this.options.plugins.forEach((t2) => this.use(t2)), "swup" !== (null == (t = history.state) ? void 0 : t.source) && r(null, { index: this.currentHistoryIndex }), await g(), await this.hooks.call("enable", void 0, () => {
      document.documentElement.classList.add("swup-enabled");
    });
  }
  async destroy() {
    this.clickDelegate.destroy(), window.removeEventListener("popstate", this.handlePopState), this.cache.clear(), this.options.plugins.forEach((t) => this.unuse(t)), await this.hooks.call("disable", void 0, () => {
      document.documentElement.classList.remove("swup-enabled");
    }), this.hooks.clear();
  }
  shouldIgnoreVisit(t, { el: e, event: i2 } = {}) {
    const { origin: s2, url: n2, hash: o2 } = l.fromUrl(t);
    return s2 !== window.location.origin || !(!e || !this.triggerWillOpenNewWindow(e)) || !!this.options.ignoreVisit(n2 + o2, { el: e, event: i2 });
  }
  handleLinkClick(t) {
    const e = t.delegateTarget, { href: i2, url: s2, hash: n2 } = l.fromElement(e);
    this.shouldIgnoreVisit(i2, { el: e, event: t }) || (this.navigating && s2 === this.visit.to.url ? t.preventDefault() : (this.visit = this.createVisit({ to: s2, hash: n2, el: e, event: t }), t.metaKey || t.ctrlKey || t.shiftKey || t.altKey ? this.hooks.call("link:newtab", { href: i2 }) : 0 === t.button && this.hooks.callSync("link:click", { el: e, event: t }, () => {
      var e2;
      const i3 = null != (e2 = this.visit.from.url) ? e2 : "";
      t.preventDefault(), s2 && s2 !== i3 ? this.isSameResolvedUrl(s2, i3) || this.performNavigation() : n2 ? this.hooks.callSync("link:anchor", { hash: n2 }, () => {
        r(s2 + n2), this.scrollToContent();
      }) : this.hooks.callSync("link:self", void 0, () => "navigate" === this.options.linkToSelf ? this.performNavigation() : (r(s2), this.scrollToContent()));
    })));
  }
  handlePopState(t) {
    var e, i2, s2, o2;
    const r2 = null != (e = null == (i2 = t.state) ? void 0 : i2.url) ? e : location.href;
    if (this.options.skipPopStateHandling(t))
      return;
    if (this.isSameResolvedUrl(n(), this.currentPageUrl))
      return;
    const { url: a2, hash: h2 } = l.fromUrl(r2);
    this.visit = this.createVisit({ to: a2, hash: h2, event: t }), this.visit.history.popstate = true;
    const c2 = null != (s2 = null == (o2 = t.state) ? void 0 : o2.index) ? s2 : 0;
    c2 && c2 !== this.currentHistoryIndex && (this.visit.history.direction = c2 - this.currentHistoryIndex > 0 ? "forwards" : "backwards", this.currentHistoryIndex = c2), this.visit.animation.animate = false, this.visit.scroll.reset = false, this.visit.scroll.target = false, this.options.animateHistoryBrowsing && (this.visit.animation.animate = true, this.visit.scroll.reset = true), this.hooks.callSync("history:popstate", { event: t }, () => {
      this.performNavigation();
    });
  }
  triggerWillOpenNewWindow(t) {
    return !!t.matches('[download], [target="_blank"]');
  }
};
export {
  l as Location,
  s as classify,
  o as createHistoryRecord,
  _ as default,
  a as delegateEvent,
  y as escapeCssIdentifier,
  v as forceReflow,
  n as getCurrentUrl,
  f as isPromise,
  h as matchPath,
  g as nextTick,
  p as query,
  m as queryAll,
  w as runAsPromise,
  k as toMs,
  r as updateHistoryRecord
};
//# sourceMappingURL=swup.js.map
