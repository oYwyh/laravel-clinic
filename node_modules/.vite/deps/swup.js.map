{
  "version": 3,
  "sources": ["../../delegate-it/delegate.js", "../../path-to-regexp/src/index.ts", "../../swup/src/helpers/classify.ts", "../../swup/src/helpers/getCurrentUrl.ts", "../../swup/src/helpers/createHistoryRecord.ts", "../../swup/src/helpers/updateHistoryRecord.ts", "../../swup/src/helpers/delegateEvent.ts", "../../swup/src/helpers/Location.ts", "../../swup/src/helpers/matchPath.ts", "../../swup/src/modules/fetchPage.ts", "../../swup/src/modules/Cache.ts", "../../swup/src/utils/index.ts", "../../swup/src/modules/Classes.ts", "../../swup/src/modules/Visit.ts", "../../swup/src/modules/Hooks.ts", "../../swup/src/modules/getAnchorElement.ts", "../../swup/src/modules/awaitAnimations.ts", "../../swup/src/modules/navigate.ts", "../../swup/src/modules/animatePageOut.ts", "../../swup/src/modules/replaceContent.ts", "../../swup/src/modules/scrollToContent.ts", "../../swup/src/modules/animatePageIn.ts", "../../swup/src/modules/renderPage.ts", "../../swup/src/modules/plugins.ts", "../../swup/src/modules/resolveUrl.ts", "../../swup/src/Swup.ts"],
  "sourcesContent": ["/** Keeps track of raw listeners added to the base elements to avoid duplication */\nconst ledger = new WeakMap();\nfunction editLedger(wanted, baseElement, callback, setup) {\n    if (!wanted && !ledger.has(baseElement)) {\n        return false;\n    }\n    const elementMap = ledger.get(baseElement)\n        ?? new WeakMap();\n    ledger.set(baseElement, elementMap);\n    const setups = elementMap.get(callback) ?? new Set();\n    elementMap.set(callback, setups);\n    const existed = setups.has(setup);\n    if (wanted) {\n        setups.add(setup);\n    }\n    else {\n        setups.delete(setup);\n    }\n    return existed && wanted;\n}\nfunction safeClosest(event, selector) {\n    let target = event.target;\n    if (target instanceof Text) {\n        target = target.parentElement;\n    }\n    if (target instanceof Element && event.currentTarget instanceof Element) {\n        // `.closest()` may match ancestors of `currentTarget` but we only need its children\n        const closest = target.closest(selector);\n        if (closest && event.currentTarget.contains(closest)) {\n            return closest;\n        }\n    }\n}\n// This type isn't exported as a declaration, so it needs to be duplicated above\nfunction delegate(selector, type, callback, options = {}) {\n    const { signal, base = document } = options;\n    if (signal?.aborted) {\n        return;\n    }\n    // Don't pass `once` to `addEventListener` because it needs to be handled in `delegate-it`\n    const { once, ...nativeListenerOptions } = options;\n    // `document` should never be the base, it's just an easy way to define \"global event listeners\"\n    const baseElement = base instanceof Document ? base.documentElement : base;\n    // Handle the regular Element usage\n    const capture = Boolean(typeof options === 'object' ? options.capture : options);\n    const listenerFn = (event) => {\n        const delegateTarget = safeClosest(event, selector);\n        if (delegateTarget) {\n            const delegateEvent = Object.assign(event, { delegateTarget });\n            callback.call(baseElement, delegateEvent);\n            if (once) {\n                baseElement.removeEventListener(type, listenerFn, nativeListenerOptions);\n                editLedger(false, baseElement, callback, setup);\n            }\n        }\n    };\n    const setup = JSON.stringify({ selector, type, capture });\n    const isAlreadyListening = editLedger(true, baseElement, callback, setup);\n    if (!isAlreadyListening) {\n        baseElement.addEventListener(type, listenerFn, nativeListenerOptions);\n    }\n    signal?.addEventListener('abort', () => {\n        editLedger(false, baseElement, callback, setup);\n    });\n}\nexport default delegate;\n", "/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\" } = options;\n  const defaultPattern = `[^${escapeString(options.delimiter || \"/#?\")}]+?`;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? defaultPattern : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {}\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map((token) => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {}\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function (pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map((value) => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\",\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n): RegExp {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {}\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x,\n    delimiter = \"/#?\",\n    endsWith = \"\",\n  } = options;\n  const endsWithRe = `[${escapeString(endsWith)}]|$`;\n  const delimiterRe = `[${escapeString(delimiter)}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            route += `((?:${token.pattern})${token.modifier})`;\n          } else {\n            route += `(${token.pattern})${token.modifier}`;\n          }\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiterRe}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWithRe})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n        : endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiterRe}(?=${endsWithRe}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiterRe}|${endsWithRe})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n", "/** Turn a string into a slug by lowercasing and replacing whitespace. */\nexport const classify = (text: string, fallback?: string): string => {\n\tconst output = String(text)\n\t\t.toLowerCase()\n\t\t// .normalize('NFD') // split an accented letter in the base letter and the acent\n\t\t// .replace(/[\\u0300-\\u036f]/g, '') // remove all previously split accents\n\t\t.replace(/[\\s/_.]+/g, '-') // replace spaces and _./ with '-'\n\t\t.replace(/[^\\w-]+/g, '') // remove all non-word chars\n\t\t.replace(/--+/g, '-') // replace repeating '-' with single '-'\n\t\t.replace(/^-+|-+$/g, ''); // trim '-' from edges\n\treturn output || fallback || '';\n};\n", "/** Get the current page URL: path name + query params. Optionally including hash. */\nexport const getCurrentUrl = ({ hash }: { hash?: boolean } = {}): string => {\n\treturn location.pathname + location.search + (hash ? location.hash : '');\n};\n", "import { getCurrentUrl } from './getCurrentUrl.js';\n\nexport interface HistoryState {\n\turl: string;\n\tsource: 'swup';\n\trandom: number;\n\tindex?: number;\n\t[key: string]: unknown;\n}\n\n/** Create a new history record with a custom swup identifier. */\nexport const createHistoryRecord = (\n\turl: string,\n\tcustomData: Record<string, unknown> = {}\n): void => {\n\turl = url || getCurrentUrl({ hash: true });\n\tconst data: HistoryState = {\n\t\turl,\n\t\trandom: Math.random(),\n\t\tsource: 'swup',\n\t\t...customData\n\t};\n\thistory.pushState(data, '', url);\n};\n", "import type { HistoryState } from './createHistoryRecord.js';\nimport { getCurrentUrl } from './getCurrentUrl.js';\n\n/** Update the current history record with a custom swup identifier. */\nexport const updateHistoryRecord = (\n\turl: string | null = null,\n\tcustomData: Record<string, unknown> = {}\n): void => {\n\turl = url || getCurrentUrl({ hash: true });\n\tconst state = (history.state as HistoryState) || {};\n\tconst data: HistoryState = {\n\t\t...state,\n\t\turl,\n\t\trandom: Math.random(),\n\t\tsource: 'swup',\n\t\t...customData\n\t};\n\thistory.replaceState(data, '', url);\n};\n", "import delegate, {\n\ttype DelegateEventHandler,\n\ttype DelegateOptions,\n\ttype EventType\n} from 'delegate-it';\nimport type { ParseSelector } from 'typed-query-selector/parser.js';\n\nexport type DelegateEventUnsubscribe = {\n\tdestroy: () => void;\n};\n\n/** Register a delegated event listener. */\nexport const delegateEvent = <\n\tSelector extends string,\n\tTElement extends Element = ParseSelector<Selector, HTMLElement>,\n\tTEvent extends EventType = EventType\n>(\n\tselector: Selector,\n\ttype: TEvent,\n\tcallback: DelegateEventHandler<GlobalEventHandlersEventMap[TEvent], TElement>,\n\toptions?: DelegateOptions\n): DelegateEventUnsubscribe => {\n\tconst controller = new AbortController();\n\toptions = { ...options, signal: controller.signal };\n\tdelegate<Selector, TElement, TEvent>(selector, type, callback, options);\n\treturn { destroy: () => controller.abort() };\n};\n", "/**\n * A helper for creating a Location from either an element\n * or a URL object/string\n *\n */\nexport class Location extends URL {\n\tconstructor(url: URL | string, base: string = document.baseURI) {\n\t\tsuper(url.toString(), base);\n\t}\n\n\t/**\n\t * The full local path including query params.\n\t */\n\tget url(): string {\n\t\treturn this.pathname + this.search;\n\t}\n\n\t/**\n\t * Instantiate a Location from an element's href attribute\n\t * @param el\n\t * @returns new Location instance\n\t */\n\tstatic fromElement(el: Element): Location {\n\t\tconst href = el.getAttribute('href') || el.getAttribute('xlink:href') || '';\n\t\treturn new Location(href);\n\t}\n\n\t/**\n\t * Instantiate a Location from a URL object or string\n\t * @param url\n\t * @returns new Location instance\n\t */\n\tstatic fromUrl(url: URL | string): Location {\n\t\treturn new Location(url);\n\t}\n}\n", "import { match } from 'path-to-regexp';\n\nimport type {\n\tPath,\n\tParseOptions,\n\tTokensToRegexpOptions,\n\tRegexpToFunctionOptions,\n\tMatchFunction\n} from 'path-to-regexp';\n\nexport { type Path };\n\n/** Create a match function from a path pattern that checks if a URLs matches it. */\nexport const matchPath = <P extends object = object>(\n\tpath: Path,\n\toptions?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions\n): MatchFunction<P> => {\n\ttry {\n\t\treturn match<P>(path, options);\n\t} catch (error) {\n\t\tthrow new Error(`[swup] Error parsing path \"${String(path)}\":\\n${String(error)}`);\n\t}\n};\n", "import type Swup from '../Swup.js';\nimport { Location } from '../helpers.js';\n\n/** A page object as used by swup and its cache. */\nexport interface PageData {\n\t/** The URL of the page */\n\turl: string;\n\t/** The complete HTML response received from the server */\n\thtml: string;\n}\n\n/** Define how a page is fetched. */\nexport interface FetchOptions extends Omit<RequestInit, 'cache'> {\n\t/** The request method. */\n\tmethod?: 'GET' | 'POST';\n\t/** The body of the request: raw string, form data object or URL params. */\n\tbody?: string | FormData | URLSearchParams;\n\t/** The request timeout in milliseconds. */\n\ttimeout?: number;\n}\n\nexport class FetchError extends Error {\n\turl: string;\n\tstatus?: number;\n\taborted: boolean;\n\ttimedOut: boolean;\n\tconstructor(\n\t\tmessage: string,\n\t\tdetails: { url: string; status?: number; aborted?: boolean; timedOut?: boolean }\n\t) {\n\t\tsuper(message);\n\t\tthis.name = 'FetchError';\n\t\tthis.url = details.url;\n\t\tthis.status = details.status;\n\t\tthis.aborted = details.aborted || false;\n\t\tthis.timedOut = details.timedOut || false;\n\t}\n}\n\n/**\n * Fetch a page from the server, return it and cache it.\n */\nexport async function fetchPage(\n\tthis: Swup,\n\turl: URL | string,\n\toptions: FetchOptions = {}\n): Promise<PageData> {\n\turl = Location.fromUrl(url).url;\n\n\tconst headers = { ...this.options.requestHeaders, ...options.headers };\n\tconst timeout = options.timeout ?? this.options.timeout;\n\tconst controller = new AbortController();\n\tconst { signal } = controller;\n\toptions = { ...options, headers, signal };\n\n\tlet timedOut = false;\n\tlet timeoutId: ReturnType<typeof setTimeout> | null = null;\n\tif (timeout && timeout > 0) {\n\t\ttimeoutId = setTimeout(() => {\n\t\t\ttimedOut = true;\n\t\t\tcontroller.abort('timeout');\n\t\t}, timeout);\n\t}\n\n\t// Allow hooking before this and returning a custom response-like object (e.g. custom fetch implementation)\n\tlet response: Response;\n\ttry {\n\t\tresponse = await this.hooks.call(\n\t\t\t'fetch:request',\n\t\t\t{ url, options },\n\t\t\t(visit, { url, options }) => fetch(url, options)\n\t\t);\n\t\tif (timeoutId) {\n\t\t\tclearTimeout(timeoutId);\n\t\t}\n\t} catch (error) {\n\t\tif (timedOut) {\n\t\t\tthis.hooks.call('fetch:timeout', { url });\n\t\t\tthrow new FetchError(`Request timed out: ${url}`, { url, timedOut });\n\t\t}\n\t\tif ((error as Error)?.name === 'AbortError' || signal.aborted) {\n\t\t\tthrow new FetchError(`Request aborted: ${url}`, {\n\t\t\t\turl: url,\n\t\t\t\taborted: true\n\t\t\t});\n\t\t}\n\t\tthrow error;\n\t}\n\n\tconst { status, url: responseUrl } = response;\n\tconst html = await response.text();\n\n\tif (status === 500) {\n\t\tthis.hooks.call('fetch:error', { status, response, url: responseUrl });\n\t\tthrow new FetchError(`Server error: ${responseUrl}`, { status, url: responseUrl });\n\t}\n\n\tif (!html) {\n\t\tthrow new FetchError(`Empty response: ${responseUrl}`, { status, url: responseUrl });\n\t}\n\n\t// Resolve real url after potential redirect\n\tconst { url: finalUrl } = Location.fromUrl(responseUrl);\n\tconst page = { url: finalUrl, html };\n\n\t// Write to cache for safe methods and non-redirects\n\tif (\n\t\tthis.visit.cache.write &&\n\t\t(!options.method || options.method === 'GET') &&\n\t\turl === finalUrl\n\t) {\n\t\tthis.cache.set(page.url, page);\n\t}\n\n\treturn page;\n}\n", "import type Swup from '../Swup.js';\nimport { Location } from '../helpers.js';\nimport { type PageData } from './fetchPage.js';\n\nexport interface CacheData extends PageData {}\n\n/**\n * In-memory page cache.\n */\nexport class Cache {\n\t/** Swup instance this cache belongs to */\n\tprotected swup: Swup;\n\n\t/** Cached pages, indexed by URL */\n\tprotected pages: Map<string, CacheData> = new Map();\n\n\tconstructor(swup: Swup) {\n\t\tthis.swup = swup;\n\t}\n\n\t/** Number of cached pages in memory. */\n\tget size(): number {\n\t\treturn this.pages.size;\n\t}\n\n\t/** All cached pages. */\n\tget all() {\n\t\tconst copy = new Map();\n\t\tthis.pages.forEach((page, key) => {\n\t\t\tcopy.set(key, { ...page });\n\t\t});\n\t\treturn copy;\n\t}\n\n\t/** Check if the given URL has been cached. */\n\thas(url: string): boolean {\n\t\treturn this.pages.has(this.resolve(url));\n\t}\n\n\t/** Return a shallow copy of the cached page object if available. */\n\tget(url: string): CacheData | undefined {\n\t\tconst result = this.pages.get(this.resolve(url));\n\t\tif (!result) return result;\n\t\treturn { ...result };\n\t}\n\n\t/** Create a cache record for the specified URL. */\n\tset(url: string, page: CacheData) {\n\t\turl = this.resolve(url);\n\t\tpage = { ...page, url };\n\t\tthis.pages.set(url, page);\n\t\tthis.swup.hooks.callSync('cache:set', { page });\n\t}\n\n\t/** Update a cache record, overwriting or adding custom data. */\n\tupdate(url: string, payload: object) {\n\t\turl = this.resolve(url);\n\t\tconst page = { ...this.get(url), ...payload, url } as CacheData;\n\t\tthis.pages.set(url, page);\n\t}\n\n\t/** Delete a cache record. */\n\tdelete(url: string): void {\n\t\tthis.pages.delete(this.resolve(url));\n\t}\n\n\t/** Empty the cache. */\n\tclear(): void {\n\t\tthis.pages.clear();\n\t\tthis.swup.hooks.callSync('cache:clear', undefined);\n\t}\n\n\t/** Remove all cache entries that return true for a given predicate function.  */\n\tprune(predicate: (url: string, page: CacheData) => boolean): void {\n\t\tthis.pages.forEach((page, url) => {\n\t\t\tif (predicate(url, page)) {\n\t\t\t\tthis.delete(url);\n\t\t\t}\n\t\t});\n\t}\n\n\t/** Resolve URLs by making them local and letting swup resolve them. */\n\tprotected resolve(urlToResolve: string): string {\n\t\tconst { url } = Location.fromUrl(urlToResolve);\n\t\treturn this.swup.resolveUrl(url);\n\t}\n}\n", "/** Find an element by selector. */\nexport const query = (selector: string, context: Document | Element = document) => {\n\treturn context.querySelector<HTMLElement>(selector);\n};\n\n/** Find a set of elements by selector. */\nexport const queryAll = (\n\tselector: string,\n\tcontext: Document | Element = document\n): HTMLElement[] => {\n\treturn Array.from(context.querySelectorAll(selector));\n};\n\n/** Return a Promise that resolves after the next event loop. */\nexport const nextTick = (): Promise<void> => {\n\treturn new Promise((resolve) => {\n\t\trequestAnimationFrame(() => {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t});\n};\n\n/** Check if an object is a Promise or a Thenable */\nexport function isPromise<T>(obj: unknown): obj is PromiseLike<T> {\n\treturn (\n\t\t!!obj &&\n\t\t(typeof obj === 'object' || typeof obj === 'function') &&\n\t\ttypeof (obj as Record<string, unknown>).then === 'function'\n\t);\n}\n\n/** Call a function as a Promise. Resolves with the returned Promsise or immediately. */\n// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any\nexport function runAsPromise(func: Function, args: unknown[] = []): Promise<unknown> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst result: unknown = func(...args);\n\t\tif (isPromise(result)) {\n\t\t\tresult.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(result);\n\t\t}\n\t});\n}\n\n/**\n * Force a layout reflow, e.g. after adding classnames\n * @returns The offset height, just here so it doesn't get optimized away by the JS engine\n * @see https://stackoverflow.com/a/21665117/3759615\n */\nexport function forceReflow(element?: HTMLElement) {\n\telement = element || document.body;\n\treturn element?.offsetHeight;\n}\n\n/** Escape a string with special chars to not break CSS selectors. */\nexport const escapeCssIdentifier = (ident: string) => {\n\t// @ts-ignore this is for support check, so it's correct that TS complains\n\tif (window.CSS && window.CSS.escape) {\n\t\treturn CSS.escape(ident);\n\t}\n\treturn ident;\n};\n\n/** Fix for Chrome below v61 formatting CSS floats with comma in some locales. */\nexport const toMs = (s: string) => {\n\treturn Number(s.slice(0, -1).replace(',', '.')) * 1000;\n};\n", "import type Swup from '../Swup.js';\nimport { queryAll } from '../utils.js';\n\nexport class Classes {\n\tprotected swup: Swup;\n\tprotected swupClasses = ['to-', 'is-changing', 'is-rendering', 'is-popstate', 'is-animating'];\n\n\tconstructor(swup: Swup) {\n\t\tthis.swup = swup;\n\t}\n\n\tprotected get selectors(): string[] {\n\t\tconst { scope } = this.swup.visit.animation;\n\t\tif (scope === 'containers') return this.swup.visit.containers;\n\t\tif (scope === 'html') return ['html'];\n\t\tif (Array.isArray(scope)) return scope;\n\t\treturn [];\n\t}\n\n\tprotected get selector(): string {\n\t\treturn this.selectors.join(',');\n\t}\n\n\tprotected get targets(): HTMLElement[] {\n\t\tif (!this.selector.trim()) return [];\n\t\treturn queryAll(this.selector);\n\t}\n\n\tadd(...classes: string[]): void {\n\t\tthis.targets.forEach((target) => target.classList.add(...classes));\n\t}\n\n\tremove(...classes: string[]): void {\n\t\tthis.targets.forEach((target) => target.classList.remove(...classes));\n\t}\n\n\tclear(): void {\n\t\tthis.targets.forEach((target) => {\n\t\t\tconst remove = target.className.split(' ').filter((c) => this.isSwupClass(c));\n\t\t\ttarget.classList.remove(...remove);\n\t\t});\n\t}\n\n\tprotected isSwupClass(className: string): boolean {\n\t\treturn this.swupClasses.some((c) => className.startsWith(c));\n\t}\n}\n", "import type Swup from '../Swup.js';\nimport type { Options } from '../Swup.js';\nimport type { HistoryAction, HistoryDirection } from './navigate.js';\n\n/** An object holding details about the current visit. */\nexport interface Visit {\n\t/** A unique ID to identify this visit */\n\tid: number;\n\t/** The previous page, about to leave */\n\tfrom: VisitFrom;\n\t/** The next page, about to enter */\n\tto: VisitTo;\n\t/** The content containers, about to be replaced */\n\tcontainers: Options['containers'];\n\t/** Information about animated page transitions */\n\tanimation: VisitAnimation;\n\t/** What triggered this visit */\n\ttrigger: VisitTrigger;\n\t/** Cache behavior for this visit */\n\tcache: VisitCache;\n\t/** Browser history behavior on this visit */\n\thistory: VisitHistory;\n\t/** Scroll behavior on this visit */\n\tscroll: VisitScroll;\n}\n\nexport interface VisitFrom {\n\t/** The URL of the previous page */\n\turl: string;\n}\n\nexport interface VisitTo {\n\t/** The URL of the next page */\n\turl: string;\n\t/** The hash of the next page */\n\thash?: string;\n\t/** The HTML content of the next page */\n\thtml?: string;\n}\n\nexport interface VisitAnimation {\n\t/** Whether this visit is animated. Default: `true` */\n\tanimate: boolean;\n\t/** Whether to wait for the next page to load before starting the animation. Default: `false` */\n\twait: boolean;\n\t/** Name of a custom animation to run. */\n\tname?: string;\n\t/** Elements on which to add animation classes. Default: `html` element */\n\tscope: 'html' | 'containers' | string[];\n\t/** Selector for detecting animation timing. Default: `[class*=\"transition-\"]` */\n\tselector: Options['animationSelector'];\n}\n\nexport interface VisitScroll {\n\t/** Whether to reset the scroll position after the visit. Default: `true` */\n\treset: boolean;\n\t/** Anchor element to scroll to on the next page. */\n\ttarget?: string | false;\n}\n\nexport interface VisitTrigger {\n\t/** DOM element that triggered this visit. */\n\tel?: Element;\n\t/** DOM event that triggered this visit. */\n\tevent?: Event;\n}\n\nexport interface VisitCache {\n\t/** Whether this visit will try to load the requested page from cache. */\n\tread: boolean;\n\t/** Whether this visit will save the loaded page in cache. */\n\twrite: boolean;\n}\n\nexport interface VisitHistory {\n\t/** History action to perform: `push` for creating a new history entry, `replace` for replacing the current entry. Default: `push` */\n\taction: HistoryAction;\n\t/** Whether this visit was triggered by a browser history navigation. */\n\tpopstate: boolean;\n\t/** The direction of travel in case of a browser history navigation: backward or forward. */\n\tdirection: HistoryDirection | undefined;\n}\n\nexport interface VisitInitOptions {\n\tto: string;\n\tfrom?: string;\n\thash?: string;\n\tel?: Element;\n\tevent?: Event;\n}\n\n/** Create a new visit object. */\nexport function createVisit(\n\tthis: Swup,\n\t{ to, from = this.currentPageUrl, hash, el, event }: VisitInitOptions\n): Visit {\n\treturn {\n\t\tid: Math.random(),\n\t\tfrom: { url: from },\n\t\tto: { url: to, hash },\n\t\tcontainers: this.options.containers,\n\t\tanimation: {\n\t\t\tanimate: true,\n\t\t\twait: false,\n\t\t\tname: undefined,\n\t\t\tscope: this.options.animationScope,\n\t\t\tselector: this.options.animationSelector\n\t\t},\n\t\ttrigger: {\n\t\t\tel,\n\t\t\tevent\n\t\t},\n\t\tcache: {\n\t\t\tread: this.options.cache,\n\t\t\twrite: this.options.cache\n\t\t},\n\t\thistory: {\n\t\t\taction: 'push',\n\t\t\tpopstate: false,\n\t\t\tdirection: undefined\n\t\t},\n\t\tscroll: {\n\t\t\treset: true,\n\t\t\ttarget: undefined\n\t\t}\n\t};\n}\n", "import type { DelegateEvent } from 'delegate-it';\n\nimport type Swup from '../Swup.js';\nimport { isPromise, runAsPromise } from '../utils.js';\nimport type { Visit } from './Visit.js';\nimport type { FetchOptions, PageData } from './fetchPage.js';\n\nexport interface HookDefinitions {\n\t'animation:out:start': undefined;\n\t'animation:out:await': { skip: boolean };\n\t'animation:out:end': undefined;\n\t'animation:in:start': undefined;\n\t'animation:in:await': { skip: boolean };\n\t'animation:in:end': undefined;\n\t'animation:skip': undefined;\n\t'cache:clear': undefined;\n\t'cache:set': { page: PageData };\n\t'content:replace': { page: PageData };\n\t'content:scroll': undefined;\n\t'enable': undefined;\n\t'disable': undefined;\n\t'fetch:request': { url: string; options: FetchOptions };\n\t'fetch:error': { url: string; status: number; response: Response };\n\t'fetch:timeout': { url: string };\n\t'history:popstate': { event: PopStateEvent };\n\t'link:click': { el: HTMLAnchorElement; event: DelegateEvent<MouseEvent> };\n\t'link:self': undefined;\n\t'link:anchor': { hash: string };\n\t'link:newtab': { href: string };\n\t'page:load': { page?: PageData; cache?: boolean; options: FetchOptions };\n\t'page:view': { url: string; title: string };\n\t'scroll:top': { options: ScrollIntoViewOptions };\n\t'scroll:anchor': { hash: string; options: ScrollIntoViewOptions };\n\t'visit:start': undefined;\n\t'visit:transition': undefined;\n\t'visit:end': undefined;\n}\n\nexport interface HookReturnValues {\n\t'content:scroll': Promise<boolean>;\n\t'fetch:request': Promise<Response>;\n\t'page:load': Promise<PageData>;\n\t'scroll:top': boolean;\n\t'scroll:anchor': boolean;\n\t'visit:transition': Promise<boolean>;\n}\n\nexport type HookArguments<T extends HookName> = HookDefinitions[T];\n\nexport type HookName = keyof HookDefinitions;\n\n/** A generic hook handler. */\nexport type HookHandler<T extends HookName> = (\n\t/** Context about the current visit. */\n\tvisit: Visit,\n\t/** Local arguments passed into the handler. */\n\targs: HookArguments<T>\n) => Promise<unknown> | unknown;\n\n/** A default hook handler with an expected return type. */\nexport type HookDefaultHandler<T extends HookName> = (\n\t/** Context about the current visit. */\n\tvisit: Visit,\n\t/** Local arguments passed into the handler. */\n\targs: HookArguments<T>,\n\t/** Default handler to be executed. Available if replacing an internal hook handler. */\n\tdefaultHandler?: HookDefaultHandler<T>\n) => T extends keyof HookReturnValues ? HookReturnValues[T] : Promise<unknown> | unknown;\n\nexport type Handlers = {\n\t[K in HookName]: HookHandler<K>[];\n};\n\n/** Unregister a previously registered hook handler. */\nexport type HookUnregister = () => void;\n\n/** Define when and how a hook handler is executed. */\nexport type HookOptions = {\n\t/** Execute the hook once, then remove the handler */\n\tonce?: boolean;\n\t/** Execute the hook before the internal default handler */\n\tbefore?: boolean;\n\t/** Set a priority for when to execute this hook. Lower numbers execute first. Default: `0` */\n\tpriority?: number;\n\t/** Replace the internal default handler with this hook handler */\n\treplace?: boolean;\n};\n\nexport type HookRegistration<\n\tT extends HookName,\n\tH extends HookHandler<T> | HookDefaultHandler<T> = HookHandler<T>\n> = {\n\tid: number;\n\thook: T;\n\thandler: H;\n\tdefaultHandler?: HookDefaultHandler<T>;\n} & HookOptions;\n\ntype HookLedger<T extends HookName> = Map<HookHandler<T>, HookRegistration<T>>;\n\ninterface HookRegistry extends Map<HookName, HookLedger<HookName>> {\n\tget<K extends HookName>(key: K): HookLedger<K> | undefined;\n\tset<K extends HookName>(key: K, value: HookLedger<K>): this;\n}\n\n/**\n * Hook registry.\n *\n * Create, trigger and handle hooks.\n *\n */\nexport class Hooks {\n\t/** Swup instance this registry belongs to */\n\tprotected swup: Swup;\n\n\t/** Map of all registered hook handlers. */\n\tprotected registry: HookRegistry = new Map();\n\n\t// Can we deduplicate this somehow? Or make it error when not in sync with HookDefinitions?\n\t// https://stackoverflow.com/questions/53387838/how-to-ensure-an-arrays-values-the-keys-of-a-typescript-interface/53395649\n\tprotected readonly hooks: HookName[] = [\n\t\t'animation:out:start',\n\t\t'animation:out:await',\n\t\t'animation:out:end',\n\t\t'animation:in:start',\n\t\t'animation:in:await',\n\t\t'animation:in:end',\n\t\t'animation:skip',\n\t\t'cache:clear',\n\t\t'cache:set',\n\t\t'content:replace',\n\t\t'content:scroll',\n\t\t'enable',\n\t\t'disable',\n\t\t'fetch:request',\n\t\t'fetch:error',\n\t\t'fetch:timeout',\n\t\t'history:popstate',\n\t\t'link:click',\n\t\t'link:self',\n\t\t'link:anchor',\n\t\t'link:newtab',\n\t\t'page:load',\n\t\t'page:view',\n\t\t'scroll:top',\n\t\t'scroll:anchor',\n\t\t'visit:start',\n\t\t'visit:transition',\n\t\t'visit:end'\n\t];\n\n\tconstructor(swup: Swup) {\n\t\tthis.swup = swup;\n\t\tthis.init();\n\t}\n\n\t/**\n\t * Create ledgers for all core hooks.\n\t */\n\tprotected init() {\n\t\tthis.hooks.forEach((hook) => this.create(hook));\n\t}\n\n\t/**\n\t * Create a new hook type.\n\t */\n\tcreate(hook: string) {\n\t\tif (!this.registry.has(hook as HookName)) {\n\t\t\tthis.registry.set(hook as HookName, new Map());\n\t\t}\n\t}\n\n\t/**\n\t * Check if a hook type exists.\n\t */\n\texists(hook: HookName): boolean {\n\t\treturn this.registry.has(hook);\n\t}\n\n\t/**\n\t * Get the ledger with all registrations for a hook.\n\t */\n\tprotected get<T extends HookName>(hook: T): HookLedger<T> | undefined {\n\t\tconst ledger = this.registry.get(hook);\n\t\tif (ledger) {\n\t\t\treturn ledger;\n\t\t}\n\t\tconsole.error(`Unknown hook '${hook}'`);\n\t}\n\n\t/**\n\t * Remove all handlers of all hooks.\n\t */\n\tclear() {\n\t\tthis.registry.forEach((ledger) => ledger.clear());\n\t}\n\n\t/**\n\t * Register a new hook handler.\n\t * @param hook Name of the hook to listen for\n\t * @param handler The handler function to execute\n\t * @param options Object to specify how and when the handler is executed\n\t *                Available options:\n\t *                - `once`: Only execute the handler once\n\t *                - `before`: Execute the handler before the default handler\n\t *                - `priority`: Specify the order in which the handlers are executed\n\t *                - `replace`: Replace the default handler with this handler\n\t * @returns A function to unregister the handler\n\t */\n\n\t// Overload: replacing default handler\n\ton<T extends HookName, O extends HookOptions>(hook: T, handler: HookDefaultHandler<T>, options: O & { replace: true }): HookUnregister; // prettier-ignore\n\t// Overload: passed in handler options\n\ton<T extends HookName, O extends HookOptions>(hook: T, handler: HookHandler<T>, options: O): HookUnregister; // prettier-ignore\n\t// Overload: no handler options\n\ton<T extends HookName>(hook: T, handler: HookHandler<T>): HookUnregister; // prettier-ignore\n\t// Implementation\n\ton<T extends HookName, O extends HookOptions>(\n\t\thook: T,\n\t\thandler: O['replace'] extends true ? HookDefaultHandler<T> : HookHandler<T>,\n\t\toptions: Partial<O> = {}\n\t): HookUnregister {\n\t\tconst ledger = this.get(hook);\n\t\tif (!ledger) {\n\t\t\tconsole.warn(`Hook '${hook}' not found.`);\n\t\t\treturn () => {};\n\t\t}\n\n\t\tconst id = ledger.size + 1;\n\t\tconst registration: HookRegistration<T> = { ...options, id, hook, handler };\n\t\tledger.set(handler, registration);\n\n\t\treturn () => this.off(hook, handler);\n\t}\n\n\t/**\n\t * Register a new hook handler to run before the default handler.\n\t * Shortcut for `hooks.on(hook, handler, { before: true })`.\n\t * @param hook Name of the hook to listen for\n\t * @param handler The handler function to execute\n\t * @param options Any other event options (see `hooks.on()` for details)\n\t * @returns A function to unregister the handler\n\t * @see on\n\t */\n\t// Overload: passed in handler options\n\tbefore<T extends HookName>(hook: T, handler: HookHandler<T>, options: HookOptions): HookUnregister; // prettier-ignore\n\t// Overload: no handler options\n\tbefore<T extends HookName>(hook: T, handler: HookHandler<T>): HookUnregister;\n\t// Implementation\n\tbefore<T extends HookName>(\n\t\thook: T,\n\t\thandler: HookHandler<T>,\n\t\toptions: HookOptions = {}\n\t): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, before: true });\n\t}\n\n\t/**\n\t * Register a new hook handler to replace the default handler.\n\t * Shortcut for `hooks.on(hook, handler, { replace: true })`.\n\t * @param hook Name of the hook to listen for\n\t * @param handler The handler function to execute instead of the default handler\n\t * @param options Any other event options (see `hooks.on()` for details)\n\t * @returns A function to unregister the handler\n\t * @see on\n\t */\n\t// Overload: passed in handler options\n\treplace<T extends HookName>(hook: T, handler: HookDefaultHandler<T>, options: HookOptions): HookUnregister; // prettier-ignore\n\t// Overload: no handler options\n\treplace<T extends HookName>(hook: T, handler: HookDefaultHandler<T>): HookUnregister; // prettier-ignore\n\t// Implementation\n\treplace<T extends HookName>(\n\t\thook: T,\n\t\thandler: HookDefaultHandler<T>,\n\t\toptions: HookOptions = {}\n\t): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, replace: true });\n\t}\n\n\t/**\n\t * Register a new hook handler to run once.\n\t * Shortcut for `hooks.on(hook, handler, { once: true })`.\n\t * @param hook Name of the hook to listen for\n\t * @param handler The handler function to execute\n\t * @param options Any other event options (see `hooks.on()` for details)\n\t * @see on\n\t */\n\t// Overload: passed in handler options\n\tonce<T extends HookName>(hook: T, handler: HookHandler<T>, options: HookOptions): HookUnregister; // prettier-ignore\n\t// Overload: no handler options\n\tonce<T extends HookName>(hook: T, handler: HookHandler<T>): HookUnregister;\n\t// Implementation\n\tonce<T extends HookName>(\n\t\thook: T,\n\t\thandler: HookHandler<T>,\n\t\toptions: HookOptions = {}\n\t): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, once: true });\n\t}\n\n\t/**\n\t * Unregister a hook handler.\n\t * @param hook Name of the hook the handler is registered for\n\t * @param handler The handler function that was registered.\n\t *                If omitted, all handlers for the hook will be removed.\n\t */\n\t// Overload: unregister a specific handler\n\toff<T extends HookName>(hook: T, handler: HookHandler<T> | HookDefaultHandler<T>): void;\n\t// Overload: unregister all handlers\n\toff<T extends HookName>(hook: T): void;\n\t// Implementation\n\toff<T extends HookName>(hook: T, handler?: HookHandler<T> | HookDefaultHandler<T>): void {\n\t\tconst ledger = this.get(hook);\n\t\tif (ledger && handler) {\n\t\t\tconst deleted = ledger.delete(handler);\n\t\t\tif (!deleted) {\n\t\t\t\tconsole.warn(`Handler for hook '${hook}' not found.`);\n\t\t\t}\n\t\t} else if (ledger) {\n\t\t\tledger.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Trigger a hook asynchronously, executing its default handler and all registered handlers.\n\t * Will execute all handlers in order and `await` any `Promise`s they return.\n\t * @param hook Name of the hook to trigger\n\t * @param args Arguments to pass to the handler\n\t * @param defaultHandler A default implementation of this hook to execute\n\t * @returns The resolved return value of the executed default handler\n\t */\n\tasync call<T extends HookName>(\n\t\thook: T,\n\t\targs: HookArguments<T>,\n\t\tdefaultHandler?: HookDefaultHandler<T>\n\t): Promise<Awaited<ReturnType<HookDefaultHandler<T>>>> {\n\t\tconst { before, handler, after } = this.getHandlers(hook, defaultHandler);\n\t\tawait this.run(before, args);\n\t\tconst [result] = await this.run(handler, args);\n\t\tawait this.run(after, args);\n\t\tthis.dispatchDomEvent(hook, args);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Trigger a hook synchronously, executing its default handler and all registered handlers.\n\t * Will execute all handlers in order, but will **not** `await` any `Promise`s they return.\n\t * @param hook Name of the hook to trigger\n\t * @param args Arguments to pass to the handler\n\t * @param defaultHandler A default implementation of this hook to execute\n\t * @returns The (possibly unresolved) return value of the executed default handler\n\t */\n\tcallSync<T extends HookName>(\n\t\thook: T,\n\t\targs: HookArguments<T>,\n\t\tdefaultHandler?: HookDefaultHandler<T>\n\t): ReturnType<HookDefaultHandler<T>> {\n\t\tconst { before, handler, after } = this.getHandlers(hook, defaultHandler);\n\t\tthis.runSync(before, args);\n\t\tconst [result] = this.runSync(handler, args);\n\t\tthis.runSync(after, args);\n\t\tthis.dispatchDomEvent(hook, args);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Execute the handlers for a hook, in order, as `Promise`s that will be `await`ed.\n\t * @param registrations The registrations (handler + options) to execute\n\t * @param args Arguments to pass to the handler\n\t */\n\n\t// Overload: running HookDefaultHandler: expect HookDefaultHandler return type\n\tprotected async run<T extends HookName>(registrations: HookRegistration<T, HookDefaultHandler<T>>[], args: HookArguments<T>): Promise<Awaited<ReturnType<HookDefaultHandler<T>>>[]>; // prettier-ignore\n\t// Overload:  running user handler: expect no specific type\n\tprotected async run<T extends HookName>(registrations: HookRegistration<T>[], args: HookArguments<T>): Promise<unknown[]>; // prettier-ignore\n\t// Implementation\n\tprotected async run<T extends HookName, R extends HookRegistration<T>[]>(\n\t\tregistrations: R,\n\t\targs: HookArguments<T>\n\t): Promise<Awaited<ReturnType<HookDefaultHandler<T>>> | unknown[]> {\n\t\tconst results = [];\n\t\tfor (const { hook, handler, defaultHandler, once } of registrations) {\n\t\t\tconst result = await runAsPromise(handler, [this.swup.visit, args, defaultHandler]);\n\t\t\tresults.push(result);\n\t\t\tif (once) {\n\t\t\t\tthis.off(hook, handler);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * Execute the handlers for a hook, in order, without `await`ing any returned `Promise`s.\n\t * @param registrations The registrations (handler + options) to execute\n\t * @param args Arguments to pass to the handler\n\t */\n\n\t// Overload: running HookDefaultHandler: expect HookDefaultHandler return type\n\tprotected runSync<T extends HookName>(registrations: HookRegistration<T, HookDefaultHandler<T>>[], args: HookArguments<T> ): ReturnType<HookDefaultHandler<T>>[]; // prettier-ignore\n\t// Overload: running user handler: expect no specific type\n\tprotected runSync<T extends HookName>(registrations: HookRegistration<T>[], args: HookArguments<T>): unknown[]; // prettier-ignore\n\t// Implementation\n\tprotected runSync<T extends HookName, R extends HookRegistration<T>[]>(\n\t\tregistrations: R,\n\t\targs: HookArguments<T>\n\t): (ReturnType<HookDefaultHandler<T>> | unknown)[] {\n\t\tconst results = [];\n\t\tfor (const { hook, handler, defaultHandler, once } of registrations) {\n\t\t\tconst result = (handler as HookDefaultHandler<T>)(this.swup.visit, args, defaultHandler); // prettier-ignore\n\t\t\tresults.push(result);\n\t\t\tif (isPromise(result)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Promise returned from handler for synchronous hook '${hook}'.` +\n\t\t\t\t\t\t`Swup will not wait for it to resolve.`\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (once) {\n\t\t\t\tthis.off(hook, handler);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * Get all registered handlers for a hook, sorted by priority and registration order.\n\t * @param hook Name of the hook\n\t * @param defaultHandler The optional default handler of this hook\n\t * @returns An object with the handlers sorted into `before` and `after` arrays,\n\t *          as well as a flag indicating if the original handler was replaced\n\t */\n\tprotected getHandlers<T extends HookName>(hook: T, defaultHandler?: HookDefaultHandler<T>) {\n\t\tconst ledger = this.get(hook);\n\t\tif (!ledger) {\n\t\t\treturn { found: false, before: [], handler: [], after: [], replaced: false };\n\t\t}\n\n\t\tconst registrations = Array.from(ledger.values());\n\n\t\t// Let TypeScript know that replaced handlers are default handlers by filtering to true\n\t\tconst def = (T: HookRegistration<T>): T is HookRegistration<T, HookDefaultHandler<T>> => true; // prettier-ignore\n\t\tconst sort = this.sortRegistrations;\n\n\t\t// Filter into before, after, and replace handlers\n\t\tconst before = registrations.filter(({ before, replace }) => before && !replace).sort(sort);\n\t\tconst replace = registrations.filter(({ replace }) => replace).filter(def).sort(sort); // prettier-ignore\n\t\tconst after = registrations.filter(({ before, replace }) => !before && !replace).sort(sort);\n\t\tconst replaced = replace.length > 0;\n\n\t\t// Define main handler registration\n\t\t// Created as HookRegistration[] array to allow passing it into hooks.run() directly\n\t\tlet handler: HookRegistration<T, HookDefaultHandler<T>>[] = [];\n\t\tif (defaultHandler) {\n\t\t\thandler = [{ id: 0, hook, handler: defaultHandler }];\n\t\t\tif (replaced) {\n\t\t\t\tconst index = replace.length - 1;\n\t\t\t\tconst replacingHandler = replace[index].handler;\n\t\t\t\tconst createDefaultHandler = (index: number): HookDefaultHandler<T> | undefined => {\n\t\t\t\t\tconst next = replace[index - 1];\n\t\t\t\t\tif (next) {\n\t\t\t\t\t\treturn (visit, args) =>\n\t\t\t\t\t\t\tnext.handler(visit, args, createDefaultHandler(index - 1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn defaultHandler;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tconst nestedDefaultHandler = createDefaultHandler(index);\n\t\t\t\thandler = [\n\t\t\t\t\t{ id: 0, hook, handler: replacingHandler, defaultHandler: nestedDefaultHandler }\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\treturn { found: true, before, handler, after, replaced };\n\t}\n\n\t/**\n\t * Sort two hook registrations by priority and registration order.\n\t * @param a The registration object to compare\n\t * @param b The other registration object to compare with\n\t * @returns The sort direction\n\t */\n\tprotected sortRegistrations<T extends HookName>(\n\t\ta: HookRegistration<T>,\n\t\tb: HookRegistration<T>\n\t): number {\n\t\tconst priority = (a.priority ?? 0) - (b.priority ?? 0);\n\t\tconst id = a.id - b.id;\n\t\treturn priority || id || 0;\n\t}\n\n\t/**\n\t * Dispatch a custom event on the `document` for a hook. Prefixed with `swup:`\n\t * @param hook Name of the hook.\n\t */\n\tprotected dispatchDomEvent<T extends HookName>(hook: T, args?: HookArguments<T>): void {\n\t\tconst detail = { hook, args, visit: this.swup.visit };\n\t\tdocument.dispatchEvent(new CustomEvent(`swup:${hook}`, { detail }));\n\t}\n}\n", "import { escapeCssIdentifier as escape, query } from '../utils.js';\n\n/**\n * Find the anchor element for a given hash.\n *\n * @param hash Hash with or without leading '#'\n * @returns The element, if found, or null.\n *\n * @see https://html.spec.whatwg.org/#find-a-potential-indicated-element\n */\nexport const getAnchorElement = (hash?: string): Element | null => {\n\tif (hash && hash.charAt(0) === '#') {\n\t\thash = hash.substring(1);\n\t}\n\n\tif (!hash) {\n\t\treturn null;\n\t}\n\n\tconst decoded = decodeURIComponent(hash);\n\tlet element =\n\t\tdocument.getElementById(hash) ||\n\t\tdocument.getElementById(decoded) ||\n\t\tquery(`a[name='${escape(hash)}']`) ||\n\t\tquery(`a[name='${escape(decoded)}']`);\n\n\tif (!element && hash === 'top') {\n\t\telement = document.body;\n\t}\n\n\treturn element;\n};\n", "import { queryAll, toMs } from '../utils.js';\nimport type Swup from '../Swup.js';\nimport type { Options } from '../Swup.js';\n\nconst TRANSITION = 'transition';\nconst ANIMATION = 'animation';\n\ntype AnimationTypes = typeof TRANSITION | typeof ANIMATION;\ntype AnimationProperties = 'Delay' | 'Duration';\ntype AnimationStyleKeys = `${AnimationTypes}${AnimationProperties}` | 'transitionProperty';\ntype AnimationStyleDeclarations = Pick<CSSStyleDeclaration, AnimationStyleKeys>;\n\nexport type AnimationDirection = 'in' | 'out';\n\n/**\n * Return a Promise that resolves when all CSS animations and transitions\n * are done on the page. Filters by selector or takes elements directly.\n */\nexport async function awaitAnimations(\n\tthis: Swup,\n\t{\n\t\telements,\n\t\tselector\n\t}: {\n\t\tselector: Options['animationSelector'];\n\t\telements?: NodeListOf<HTMLElement> | HTMLElement[];\n\t}\n): Promise<void> {\n\t// Allow usage of swup without animations: { animationSelector: false }\n\tif (selector === false && !elements) {\n\t\treturn;\n\t}\n\n\t// Allow passing in elements\n\tlet animatedElements: HTMLElement[] = [];\n\tif (elements) {\n\t\tanimatedElements = Array.from(elements);\n\t} else if (selector) {\n\t\tanimatedElements = queryAll(selector, document.body);\n\t\t// Warn if no elements match the selector, but keep things going\n\t\tif (!animatedElements.length) {\n\t\t\tconsole.warn(`[swup] No elements found matching animationSelector \\`${selector}\\``);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tconst awaitedAnimations = animatedElements.map((el) => awaitAnimationsOnElement(el));\n\tconst hasAnimations = awaitedAnimations.filter(Boolean).length > 0;\n\tif (!hasAnimations) {\n\t\tif (selector) {\n\t\t\tconsole.warn(\n\t\t\t\t`[swup] No CSS animation duration defined on elements matching \\`${selector}\\``\n\t\t\t);\n\t\t}\n\t\treturn;\n\t}\n\n\tawait Promise.all(awaitedAnimations);\n}\n\nfunction awaitAnimationsOnElement(element: Element): Promise<void> | false {\n\tconst { type, timeout, propCount } = getTransitionInfo(element);\n\n\t// Resolve immediately if no transition defined\n\tif (!type || !timeout) {\n\t\treturn false;\n\t}\n\n\treturn new Promise((resolve) => {\n\t\tconst endEvent = `${type}end`;\n\t\tconst startTime = performance.now();\n\t\tlet propsTransitioned = 0;\n\n\t\tconst end = () => {\n\t\t\telement.removeEventListener(endEvent, onEnd);\n\t\t\tresolve();\n\t\t};\n\n\t\tconst onEnd: EventListener = (event) => {\n\t\t\t// Skip transitions on child elements\n\t\t\tif (event.target !== element) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!isTransitionOrAnimationEvent(event)) {\n\t\t\t\tthrow new Error('Not a transition or animation event.');\n\t\t\t}\n\n\t\t\t// Skip transitions that happened before we started listening\n\t\t\tconst elapsedTime = (performance.now() - startTime) / 1000;\n\t\t\tif (elapsedTime < event.elapsedTime) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// End if all properties have transitioned\n\t\t\tif (++propsTransitioned >= propCount) {\n\t\t\t\tend();\n\t\t\t}\n\t\t};\n\n\t\tsetTimeout(() => {\n\t\t\tif (propsTransitioned < propCount) {\n\t\t\t\tend();\n\t\t\t}\n\t\t}, timeout + 1);\n\n\t\telement.addEventListener(endEvent, onEnd);\n\t});\n}\n\nexport function getTransitionInfo(element: Element, expectedType?: AnimationTypes) {\n\tconst styles = window.getComputedStyle(element) as AnimationStyleDeclarations;\n\n\tconst transitionDelays = getStyleProperties(styles, `${TRANSITION}Delay`);\n\tconst transitionDurations = getStyleProperties(styles, `${TRANSITION}Duration`);\n\tconst transitionTimeout = calculateTimeout(transitionDelays, transitionDurations);\n\tconst animationDelays = getStyleProperties(styles, `${ANIMATION}Delay`);\n\tconst animationDurations = getStyleProperties(styles, `${ANIMATION}Duration`);\n\tconst animationTimeout = calculateTimeout(animationDelays, animationDurations);\n\n\tlet type: AnimationTypes | null = null;\n\tlet timeout = 0;\n\tlet propCount = 0;\n\n\tif (expectedType === TRANSITION) {\n\t\tif (transitionTimeout > 0) {\n\t\t\ttype = TRANSITION;\n\t\t\ttimeout = transitionTimeout;\n\t\t\tpropCount = transitionDurations.length;\n\t\t}\n\t} else if (expectedType === ANIMATION) {\n\t\tif (animationTimeout > 0) {\n\t\t\ttype = ANIMATION;\n\t\t\ttimeout = animationTimeout;\n\t\t\tpropCount = animationDurations.length;\n\t\t}\n\t} else {\n\t\ttimeout = Math.max(transitionTimeout, animationTimeout);\n\t\ttype = timeout > 0 ? (transitionTimeout > animationTimeout ? TRANSITION : ANIMATION) : null;\n\t\tpropCount = type\n\t\t\t? type === TRANSITION\n\t\t\t\t? transitionDurations.length\n\t\t\t\t: animationDurations.length\n\t\t\t: 0;\n\t}\n\n\treturn {\n\t\ttype,\n\t\ttimeout,\n\t\tpropCount\n\t};\n}\n\nfunction isTransitionOrAnimationEvent(event: Event): event is TransitionEvent | AnimationEvent {\n\treturn [`${TRANSITION}end`, `${ANIMATION}end`].includes(event.type);\n}\n\nfunction getStyleProperties(styles: AnimationStyleDeclarations, key: AnimationStyleKeys): string[] {\n\treturn (styles[key] || '').split(', ');\n}\n\nfunction calculateTimeout(delays: string[], durations: string[]): number {\n\twhile (delays.length < durations.length) {\n\t\tdelays = delays.concat(delays);\n\t}\n\n\treturn Math.max(...durations.map((duration, i) => toMs(duration) + toMs(delays[i])));\n}\n", "import type Swup from '../Swup.js';\nimport { createHistoryRecord, updateHistoryRecord, getCurrentUrl, Location } from '../helpers.js';\nimport { FetchError, type FetchOptions, type PageData } from './fetchPage.js';\nimport type { VisitInitOptions } from './Visit.js';\n\nexport type HistoryAction = 'push' | 'replace';\nexport type HistoryDirection = 'forwards' | 'backwards';\nexport type NavigationToSelfAction = 'scroll' | 'navigate';\nexport type CacheControl = Partial<{ read: boolean; write: boolean }>;\n\n/** Define how to navigate to a page. */\ntype NavigationOptions = {\n\t/** Whether this visit is animated. Default: `true` */\n\tanimate?: boolean;\n\t/** Name of a custom animation to run. */\n\tanimation?: string;\n\t/** History action to perform: `push` for creating a new history entry, `replace` for replacing the current entry. Default: `push` */\n\thistory?: HistoryAction;\n\t/** Whether this visit should read from or write to the cache. */\n\tcache?: CacheControl;\n};\n\n/**\n * Navigate to a new URL.\n * @param url The URL to navigate to.\n * @param options Options for how to perform this visit.\n * @returns Promise<void>\n */\nexport function navigate(\n\tthis: Swup,\n\turl: string,\n\toptions: NavigationOptions & FetchOptions = {},\n\tinit: Omit<VisitInitOptions, 'to'> = {}\n) {\n\tif (typeof url !== 'string') {\n\t\tthrow new Error(`swup.navigate() requires a URL parameter`);\n\t}\n\n\t// Check if the visit should be ignored\n\tif (this.shouldIgnoreVisit(url, { el: init.el, event: init.event })) {\n\t\twindow.location.href = url;\n\t\treturn;\n\t}\n\n\tconst { url: to, hash } = Location.fromUrl(url);\n\tthis.visit = this.createVisit({ ...init, to, hash });\n\tthis.performNavigation(options);\n}\n\n/**\n * Start a visit to a new URL.\n *\n * Internal method that assumes the visit context has already been created.\n *\n * As a user, you should call `swup.navigate(url)` instead.\n *\n * @param url The URL to navigate to.\n * @param options Options for how to perform this visit.\n * @returns Promise<void>\n */\nexport async function performNavigation(\n\tthis: Swup,\n\toptions: NavigationOptions & FetchOptions = {}\n): Promise<void> {\n\tthis.navigating = true;\n\t// Save this localy to a) allow ignoring the visit if a new one was started in the meantime\n\t// and b) avoid unintended modifications to any newer visits\n\tconst visit = this.visit;\n\n\tconst { el } = visit.trigger;\n\toptions.referrer = options.referrer || this.currentPageUrl;\n\n\tif (options.animate === false) {\n\t\tvisit.animation.animate = false;\n\t}\n\n\t// Clean up old animation classes\n\tif (!visit.animation.animate) {\n\t\tthis.classes.clear();\n\t}\n\n\t// Get history action from option or attribute on trigger element\n\tconst history = options.history || el?.getAttribute('data-swup-history') || undefined;\n\tif (history && ['push', 'replace'].includes(history)) {\n\t\tvisit.history.action = history as HistoryAction;\n\t}\n\n\t// Get custom animation name from option or attribute on trigger element\n\tconst animation = options.animation || el?.getAttribute('data-swup-animation') || undefined;\n\tif (animation) {\n\t\tvisit.animation.name = animation;\n\t}\n\n\t// Sanitize cache option\n\tif (typeof options.cache === 'object') {\n\t\tvisit.cache.read = options.cache.read ?? visit.cache.read;\n\t\tvisit.cache.write = options.cache.write ?? visit.cache.write;\n\t} else if (options.cache !== undefined) {\n\t\tvisit.cache = { read: !!options.cache, write: !!options.cache };\n\t}\n\t// Delete this so that window.fetch doesn't mis-interpret it\n\tdelete options.cache;\n\n\ttry {\n\t\tawait this.hooks.call('visit:start', undefined);\n\n\t\t// Begin loading page\n\t\tconst pagePromise = this.hooks.call('page:load', { options }, async (visit, args) => {\n\t\t\t// Read from cache\n\t\t\tlet cachedPage: PageData | undefined;\n\t\t\tif (visit.cache.read) {\n\t\t\t\tcachedPage = this.cache.get(visit.to.url);\n\t\t\t}\n\n\t\t\targs.page = cachedPage || (await this.fetchPage(visit.to.url, args.options));\n\t\t\targs.cache = !!cachedPage;\n\n\t\t\treturn args.page;\n\t\t});\n\n\t\t// Create/update history record if this is not a popstate call or leads to the same URL\n\t\tif (!visit.history.popstate) {\n\t\t\t// Add the hash directly from the trigger element\n\t\t\tconst newUrl = visit.to.url + visit.to.hash;\n\t\t\tif (visit.history.action === 'replace' || visit.to.url === this.currentPageUrl) {\n\t\t\t\tupdateHistoryRecord(newUrl);\n\t\t\t} else {\n\t\t\t\tthis.currentHistoryIndex++;\n\t\t\t\tcreateHistoryRecord(newUrl, { index: this.currentHistoryIndex });\n\t\t\t}\n\t\t}\n\n\t\tthis.currentPageUrl = getCurrentUrl();\n\n\t\t// Wait for page before starting to animate out?\n\t\tif (visit.animation.wait) {\n\t\t\tconst { html } = await pagePromise;\n\t\t\tvisit.to.html = html;\n\t\t}\n\n\t\t// perform the actual transition: animate and replace content\n\t\tawait this.hooks.call('visit:transition', undefined, async (visit) => {\n\t\t\t// Start leave animation\n\t\t\tconst animationPromise = this.animatePageOut();\n\n\t\t\t// Wait for page to load and leave animation to finish\n\t\t\tconst [page] = await Promise.all([pagePromise, animationPromise]);\n\n\t\t\t// Abort if another visit was started in the meantime\n\t\t\tif (visit.id !== this.visit.id) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Render page: replace content and scroll to top/fragment\n\t\t\tawait this.renderPage(page);\n\n\t\t\t// Wait for enter animation\n\t\t\tawait this.animatePageIn();\n\n\t\t\treturn true;\n\t\t});\n\n\t\t// Finalize visit\n\t\tawait this.hooks.call('visit:end', undefined, () => this.classes.clear());\n\n\t\t// Reset visit info after finish?\n\t\t// if (visit.to && this.isSameResolvedUrl(visit.to.url, requestedUrl)) {\n\t\t// \tthis.visit = this.createVisit({ to: undefined });\n\t\t// }\n\t\tthis.navigating = false;\n\t} catch (error) {\n\t\t// Return early if error is undefined or signals an aborted request\n\t\tif (!error || (error as FetchError)?.aborted) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Log to console as we swallow almost all hook errors\n\t\tconsole.error(error);\n\n\t\t// Rewrite `skipPopStateHandling` to redirect manually when `history.go` is processed\n\t\tthis.options.skipPopStateHandling = () => {\n\t\t\twindow.location.href = visit.to.url + visit.to.hash;\n\t\t\treturn true;\n\t\t};\n\n\t\t// Go back to the actual page we're still at\n\t\twindow.history.go(-1);\n\t}\n}\n", "import type Swup from '../Swup.js';\nimport { classify } from '../helpers.js';\n\n/**\n * Perform the out/leave animation of the current page.\n * @returns Promise<void>\n */\nexport const animatePageOut = async function (this: Swup) {\n\tif (!this.visit.animation.animate) {\n\t\tawait this.hooks.call('animation:skip', undefined);\n\t\treturn;\n\t}\n\n\tawait this.hooks.call('animation:out:start', undefined, (visit) => {\n\t\tthis.classes.add('is-changing', 'is-leaving', 'is-animating');\n\t\tif (visit.history.popstate) {\n\t\t\tthis.classes.add('is-popstate');\n\t\t}\n\t\tif (visit.animation.name) {\n\t\t\tthis.classes.add(`to-${classify(visit.animation.name)}`);\n\t\t}\n\t});\n\n\tawait this.hooks.call('animation:out:await', { skip: false }, async (visit, { skip }) => {\n\t\tif (skip) return;\n\t\tawait this.awaitAnimations({ selector: visit.animation.selector });\n\t});\n\n\tawait this.hooks.call('animation:out:end', undefined);\n};\n", "import type Swup from '../Swup.js';\nimport type { Options } from '../Swup.js';\nimport { query, queryAll } from '../utils.js';\nimport type { PageData } from './fetchPage.js';\n\n/**\n * Perform the replacement of content after loading a page.\n *\n * It takes an object with the page data as returned from `fetchPage` and a list\n * of container selectors to replace.\n *\n * @returns Whether all containers were replaced.\n */\nexport const replaceContent = function (\n\tthis: Swup,\n\t{ html }: PageData,\n\t{ containers }: { containers: Options['containers'] } = this.options\n): boolean {\n\tconst incomingDocument = new DOMParser().parseFromString(html, 'text/html');\n\n\t// Update browser title\n\tconst title = incomingDocument.querySelector('title')?.innerText || '';\n\tdocument.title = title;\n\n\t// Save persisted elements\n\tconst persistedElements = queryAll('[data-swup-persist]:not([data-swup-persist=\"\"])');\n\n\t// Update content containers\n\tconst replaced = containers\n\t\t.map((selector) => {\n\t\t\tconst currentEl = document.querySelector(selector);\n\t\t\tconst incomingEl = incomingDocument.querySelector(selector);\n\t\t\tif (currentEl && incomingEl) {\n\t\t\t\tcurrentEl.replaceWith(incomingEl);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!currentEl) {\n\t\t\t\tconsole.warn(`[swup] Container missing in current document: ${selector}`);\n\t\t\t}\n\t\t\tif (!incomingEl) {\n\t\t\t\tconsole.warn(`[swup] Container missing in incoming document: ${selector}`);\n\t\t\t}\n\t\t\treturn false;\n\t\t})\n\t\t.filter(Boolean);\n\n\t// Restore persisted elements\n\tpersistedElements.forEach((existing) => {\n\t\tconst key = existing.getAttribute('data-swup-persist');\n\t\tconst replacement = query(`[data-swup-persist=\"${key}\"]`);\n\t\tif (replacement && replacement !== existing) {\n\t\t\treplacement.replaceWith(existing);\n\t\t}\n\t});\n\n\treturn replaced.length === containers.length;\n};\n", "import type Swup from '../Swup.js';\n\n/**\n * Update the scroll position after page render.\n * @returns Promise<boolean>\n */\nexport const scrollToContent = function (this: Swup): boolean {\n\tconst options: ScrollIntoViewOptions = { behavior: 'auto' };\n\tconst { target, reset } = this.visit.scroll;\n\tconst scrollTarget = target ?? this.visit.to.hash;\n\n\tlet scrolled = false;\n\n\tif (scrollTarget) {\n\t\tscrolled = this.hooks.callSync(\n\t\t\t'scroll:anchor',\n\t\t\t{ hash: scrollTarget, options },\n\t\t\t(visit, { hash, options }) => {\n\t\t\t\tconst anchor = this.getAnchorElement(hash);\n\t\t\t\tif (anchor) {\n\t\t\t\t\tanchor.scrollIntoView(options);\n\t\t\t\t}\n\t\t\t\treturn !!anchor;\n\t\t\t}\n\t\t);\n\t}\n\n\tif (reset && !scrolled) {\n\t\tscrolled = this.hooks.callSync('scroll:top', { options }, (visit, { options }) => {\n\t\t\twindow.scrollTo({ top: 0, left: 0, ...options });\n\t\t\treturn true;\n\t\t});\n\t}\n\n\treturn scrolled;\n};\n", "import type Swup from '../Swup.js';\nimport { nextTick } from '../utils.js';\n\n/**\n * Perform the in/enter animation of the next page.\n * @returns Promise<void>\n */\nexport const animatePageIn = async function (this: Swup) {\n\tif (!this.visit.animation.animate) {\n\t\treturn;\n\t}\n\n\tconst animation = this.hooks.call(\n\t\t'animation:in:await',\n\t\t{ skip: false },\n\t\tasync (visit, { skip }) => {\n\t\t\tif (skip) return;\n\t\t\tawait this.awaitAnimations({ selector: visit.animation.selector });\n\t\t}\n\t);\n\n\tawait nextTick();\n\n\tawait this.hooks.call('animation:in:start', undefined, () => {\n\t\tthis.classes.remove('is-animating');\n\t});\n\n\tawait animation;\n\n\tawait this.hooks.call('animation:in:end', undefined);\n};\n", "import { updateHistoryRecord, getCurrentUrl, classify } from '../helpers.js';\nimport type Swup from '../Swup.js';\nimport type { PageData } from './fetchPage.js';\n\n/**\n * Render the next page: replace the content and update scroll position.\n */\nexport const renderPage = async function (this: Swup, page: PageData): Promise<void> {\n\tconst { url, html } = page;\n\n\tthis.classes.remove('is-leaving');\n\n\t// update state if the url was redirected\n\tif (!this.isSameResolvedUrl(getCurrentUrl(), url)) {\n\t\tupdateHistoryRecord(url);\n\t\tthis.currentPageUrl = getCurrentUrl();\n\t\tthis.visit.to.url = this.currentPageUrl;\n\t}\n\n\t// only add for animated page loads\n\tif (this.visit.animation.animate) {\n\t\tthis.classes.add('is-rendering');\n\t}\n\n\t// save html into visit context for easier retrieval\n\tthis.visit.to.html = html;\n\n\t// replace content: allow handlers and plugins to overwrite paga data and containers\n\tawait this.hooks.call('content:replace', { page }, (visit, { page }) => {\n\t\tconst success = this.replaceContent(page, { containers: visit.containers });\n\t\tif (!success) {\n\t\t\tthrow new Error('[swup] Container mismatch, aborting');\n\t\t}\n\t\tif (visit.animation.animate) {\n\t\t\t// Make sure to add these classes to new containers as well\n\t\t\tthis.classes.add('is-animating', 'is-changing', 'is-rendering');\n\t\t\tif (visit.animation.name) {\n\t\t\t\tthis.classes.add(`to-${classify(visit.animation.name)}`);\n\t\t\t}\n\t\t}\n\t});\n\n\t// scroll into view: either anchor or top of page\n\t// @ts-ignore: not returning a promise is intentional to allow users to pause in handler\n\tawait this.hooks.call('content:scroll', undefined, () => {\n\t\treturn this.scrollToContent();\n\t});\n\n\tawait this.hooks.call('page:view', { url: this.currentPageUrl, title: document.title });\n};\n", "import type Swup from '../Swup.js';\n\nexport type Plugin = {\n\t/** Identify as a swup plugin */\n\tisSwupPlugin: true;\n\t/** Name of this plugin */\n\tname: string;\n\t/** Version of this plugin. Currently not in use, defined here for backward compatiblity. */\n\tversion?: string;\n\t/** The swup instance that mounted this plugin */\n\tswup?: Swup;\n\t/** Version requirements of this plugin. Example: `{ swup: '>=4' }` */\n\trequires?: Record<string, string | string[]>;\n\t/** Run on mount */\n\tmount: () => void;\n\t/** Run on unmount */\n\tunmount: () => void;\n\t_beforeMount?: () => void;\n\t_afterUnmount?: () => void;\n\t_checkRequirements?: () => boolean;\n};\n\nconst isSwupPlugin = (maybeInvalidPlugin: unknown): maybeInvalidPlugin is Plugin => {\n\t// @ts-ignore: this might be anything, object or no\n\treturn Boolean(maybeInvalidPlugin?.isSwupPlugin);\n};\n\n/** Install a plugin. */\nexport const use = function (this: Swup, plugin: unknown) {\n\tif (!isSwupPlugin(plugin)) {\n\t\tconsole.error('Not a swup plugin instance', plugin);\n\t\treturn;\n\t}\n\n\tplugin.swup = this;\n\tif (plugin._checkRequirements) {\n\t\tif (!plugin._checkRequirements()) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (plugin._beforeMount) {\n\t\tplugin._beforeMount();\n\t}\n\tplugin.mount();\n\n\tthis.plugins.push(plugin);\n\n\treturn this.plugins;\n};\n\n/** Uninstall a plugin. */\nexport function unuse(this: Swup, pluginOrName: Plugin | string) {\n\tconst plugin = this.findPlugin(pluginOrName);\n\tif (!plugin) {\n\t\tconsole.error('No such plugin', plugin);\n\t\treturn;\n\t}\n\n\tplugin.unmount();\n\tif (plugin._afterUnmount) {\n\t\tplugin._afterUnmount();\n\t}\n\n\tthis.plugins = this.plugins.filter((p) => p !== plugin);\n\n\treturn this.plugins;\n}\n\n/** Find a plugin by name or reference. */\nexport function findPlugin(this: Swup, pluginOrName: Plugin | string) {\n\treturn this.plugins.find(\n\t\t(plugin) =>\n\t\t\tplugin === pluginOrName ||\n\t\t\tplugin.name === pluginOrName ||\n\t\t\tplugin.name === `Swup${String(pluginOrName)}`\n\t);\n}\n", "import type Swup from '../Swup.js';\n\n/**\n * Utility function to validate and run the global option 'resolveUrl'\n * @param {string} url\n * @returns {string} the resolved url\n */\nexport function resolveUrl(this: Swup, url: string): string {\n\tif (typeof this.options.resolveUrl !== 'function') {\n\t\tconsole.warn(`[swup] options.resolveUrl expects a callback function.`);\n\t\treturn url;\n\t}\n\tconst result = this.options.resolveUrl(url);\n\tif (!result || typeof result !== 'string') {\n\t\tconsole.warn(`[swup] options.resolveUrl needs to return a url`);\n\t\treturn url;\n\t}\n\tif (result.startsWith('//') || result.startsWith('http')) {\n\t\tconsole.warn(`[swup] options.resolveUrl needs to return a relative url`);\n\t\treturn url;\n\t}\n\treturn result;\n}\n\n/**\n * Compares the resolved version of two paths and returns true if they are the same\n * @param {string} url1\n * @param {string} url2\n * @returns {boolean}\n */\nexport function isSameResolvedUrl(this: Swup, url1: string, url2: string): boolean {\n\treturn this.resolveUrl(url1) === this.resolveUrl(url2);\n}\n", "import { type DelegateEvent } from 'delegate-it';\n\nimport version from './config/version.js';\n\nimport { delegateEvent, getCurrentUrl, Location, updateHistoryRecord } from './helpers.js';\nimport { type DelegateEventUnsubscribe } from './helpers/delegateEvent.js';\n\nimport { Cache } from './modules/Cache.js';\nimport { Classes } from './modules/Classes.js';\nimport { type Visit, createVisit } from './modules/Visit.js';\nimport { Hooks } from './modules/Hooks.js';\nimport { getAnchorElement } from './modules/getAnchorElement.js';\nimport { awaitAnimations } from './modules/awaitAnimations.js';\nimport { navigate, performNavigation, type NavigationToSelfAction } from './modules/navigate.js';\nimport { fetchPage } from './modules/fetchPage.js';\nimport { animatePageOut } from './modules/animatePageOut.js';\nimport { replaceContent } from './modules/replaceContent.js';\nimport { scrollToContent } from './modules/scrollToContent.js';\nimport { animatePageIn } from './modules/animatePageIn.js';\nimport { renderPage } from './modules/renderPage.js';\nimport { use, unuse, findPlugin, type Plugin } from './modules/plugins.js';\nimport { isSameResolvedUrl, resolveUrl } from './modules/resolveUrl.js';\nimport { nextTick } from './utils.js';\nimport { type HistoryState } from './helpers/createHistoryRecord.js';\n\n/** Options for customizing swup's behavior. */\nexport type Options = {\n\t/** Whether history visits are animated. Default: `false` */\n\tanimateHistoryBrowsing: boolean;\n\t/** Selector for detecting animation timing. Default: `[class*=\"transition-\"]` */\n\tanimationSelector: string | false;\n\t/** Elements on which to add animation classes. Default: `html` element */\n\tanimationScope: 'html' | 'containers';\n\t/** Enable in-memory page cache. Default: `true` */\n\tcache: boolean;\n\t/** Content containers to be replaced on page visits. Default: `['#swup']` */\n\tcontainers: string[];\n\t/** Callback for ignoring visits. Receives the element and event that triggered the visit. */\n\tignoreVisit: (url: string, { el, event }: { el?: Element; event?: Event }) => boolean;\n\t/** Selector for links that trigger visits. Default: `'a[href]'` */\n\tlinkSelector: string;\n\t/** How swup handles links to the same page. Default: `scroll` */\n\tlinkToSelf: NavigationToSelfAction;\n\t/** Plugins to register on startup. */\n\tplugins: Plugin[];\n\t/** Custom headers sent along with fetch requests. */\n\trequestHeaders: Record<string, string>;\n\t/** Rewrite URLs before loading them. */\n\tresolveUrl: (url: string) => string;\n\t/** Callback for telling swup to ignore certain popstate events.  */\n\tskipPopStateHandling: (event: PopStateEvent) => boolean;\n\t/** Request timeout in milliseconds. */\n\ttimeout: number;\n};\n\nconst defaults: Options = {\n\tanimateHistoryBrowsing: false,\n\tanimationSelector: '[class*=\"transition-\"]',\n\tanimationScope: 'html',\n\tcache: true,\n\tcontainers: ['#swup'],\n\tignoreVisit: (url, { el } = {}) => !!el?.closest('[data-no-swup]'),\n\tlinkSelector: 'a[href]',\n\tlinkToSelf: 'scroll',\n\tplugins: [],\n\tresolveUrl: (url) => url,\n\trequestHeaders: {\n\t\t'X-Requested-With': 'swup',\n\t\t'Accept': 'text/html, application/xhtml+xml'\n\t},\n\tskipPopStateHandling: (event) => (event.state as HistoryState)?.source !== 'swup',\n\ttimeout: 0\n};\n\n/** Swup page transition library. */\nexport default class Swup {\n\t/** Library version */\n\treadonly version: string = version;\n\t/** Options passed into the instance */\n\toptions: Options;\n\t/** Default options before merging user options */\n\treadonly defaults: Options = defaults;\n\t/** Registered plugin instances */\n\tplugins: Plugin[] = [];\n\t/** Data about the current visit */\n\tvisit: Visit;\n\t/** Cache instance */\n\treadonly cache: Cache;\n\t/** Hook registry */\n\treadonly hooks: Hooks;\n\t/** Animation class manager */\n\treadonly classes: Classes;\n\t/** URL of the currently visible page */\n\tcurrentPageUrl: string = getCurrentUrl();\n\t/** Index of the current history entry */\n\tprotected currentHistoryIndex: number;\n\t/** Delegated event subscription handle */\n\tprotected clickDelegate?: DelegateEventUnsubscribe;\n\t/** Navigation status */\n\tprotected navigating: boolean = false;\n\n\t/** Install a plugin */\n\tuse = use;\n\t/** Uninstall a plugin */\n\tunuse = unuse;\n\t/** Find a plugin by name or instance */\n\tfindPlugin = findPlugin;\n\n\t/** Log a message. Has no effect unless debug plugin is installed */\n\tlog: (message: string, context?: unknown) => void = () => {};\n\n\t/** Navigate to a new URL */\n\tnavigate = navigate;\n\t/** Actually perform a navigation */\n\tprotected performNavigation = performNavigation;\n\t/** Create a new context for this visit */\n\tprotected createVisit = createVisit;\n\t/** Register a delegated event listener */\n\tdelegateEvent = delegateEvent;\n\t/** Fetch a page from the server */\n\tfetchPage = fetchPage;\n\t/** Resolve when animations on the page finish */\n\tawaitAnimations = awaitAnimations;\n\tprotected renderPage = renderPage;\n\t/** Replace the content after page load */\n\treplaceContent = replaceContent;\n\tprotected animatePageIn = animatePageIn;\n\tprotected animatePageOut = animatePageOut;\n\tprotected scrollToContent = scrollToContent;\n\t/** Find the anchor element for a given hash */\n\tgetAnchorElement = getAnchorElement;\n\n\t/** Get the current page URL */\n\tgetCurrentUrl = getCurrentUrl;\n\t/** Resolve a URL to its final location */\n\tresolveUrl = resolveUrl;\n\t/** Check if two URLs resolve to the same location */\n\tprotected isSameResolvedUrl = isSameResolvedUrl;\n\n\tconstructor(options: Partial<Options> = {}) {\n\t\t// Merge defaults and options\n\t\tthis.options = { ...this.defaults, ...options };\n\n\t\tthis.handleLinkClick = this.handleLinkClick.bind(this);\n\t\tthis.handlePopState = this.handlePopState.bind(this);\n\n\t\tthis.cache = new Cache(this);\n\t\tthis.classes = new Classes(this);\n\t\tthis.hooks = new Hooks(this);\n\t\tthis.visit = this.createVisit({ to: '' });\n\n\t\tthis.currentHistoryIndex = (history.state as HistoryState)?.index ?? 1;\n\n\t\tif (!this.checkRequirements()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.enable();\n\t}\n\n\tprotected checkRequirements() {\n\t\tif (typeof Promise === 'undefined') {\n\t\t\tconsole.warn('Promise is not supported');\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/** Enable this instance, adding listeners and classnames. */\n\tasync enable() {\n\t\t// Add event listener\n\t\tconst { linkSelector } = this.options;\n\t\tthis.clickDelegate = this.delegateEvent(linkSelector, 'click', this.handleLinkClick);\n\n\t\twindow.addEventListener('popstate', this.handlePopState);\n\n\t\t// Set scroll restoration to manual if animating history visits\n\t\tif (this.options.animateHistoryBrowsing) {\n\t\t\twindow.history.scrollRestoration = 'manual';\n\t\t}\n\n\t\t// Initial save to cache\n\t\tif (this.options.cache) {\n\t\t\t// Disabled to avoid caching modified dom state: logic moved to preload plugin\n\t\t\t// https://github.com/swup/swup/issues/475\n\t\t}\n\n\t\t// Mount plugins\n\t\tthis.options.plugins.forEach((plugin) => this.use(plugin));\n\n\t\t// Create initial history record\n\t\tif ((history.state as HistoryState)?.source !== 'swup') {\n\t\t\tupdateHistoryRecord(null, { index: this.currentHistoryIndex });\n\t\t}\n\n\t\t// Give consumers a chance to hook into enable\n\t\tawait nextTick();\n\n\t\t// Trigger enable hook\n\t\tawait this.hooks.call('enable', undefined, () => {\n\t\t\t// Add swup-enabled class to html tag\n\t\t\tdocument.documentElement.classList.add('swup-enabled');\n\t\t});\n\t}\n\n\t/** Disable this instance, removing listeners and classnames. */\n\tasync destroy() {\n\t\t// remove delegated listener\n\t\tthis.clickDelegate!.destroy();\n\n\t\t// remove popstate listener\n\t\twindow.removeEventListener('popstate', this.handlePopState);\n\n\t\t// empty cache\n\t\tthis.cache.clear();\n\n\t\t// unmount plugins\n\t\tthis.options.plugins.forEach((plugin) => this.unuse(plugin));\n\n\t\t// trigger disable hook\n\t\tawait this.hooks.call('disable', undefined, () => {\n\t\t\t// remove swup-enabled class from html tag\n\t\t\tdocument.documentElement.classList.remove('swup-enabled');\n\t\t});\n\n\t\t// remove handlers\n\t\tthis.hooks.clear();\n\t}\n\n\t/** Determine if a visit should be ignored by swup, based on URL or trigger element. */\n\tshouldIgnoreVisit(href: string, { el, event }: { el?: Element; event?: Event } = {}) {\n\t\tconst { origin, url, hash } = Location.fromUrl(href);\n\n\t\t// Ignore if the new origin doesn't match the current one\n\t\tif (origin !== window.location.origin) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ignore if the link/form would open a new window (or none at all)\n\t\tif (el && this.triggerWillOpenNewWindow(el)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ignore if the visit should be ignored as per user options\n\t\tif (this.options.ignoreVisit(url + hash, { el, event })) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Finally, allow the visit\n\t\treturn false;\n\t}\n\n\tprotected handleLinkClick(event: DelegateEvent<MouseEvent>) {\n\t\tconst el = event.delegateTarget as HTMLAnchorElement;\n\t\tconst { href, url, hash } = Location.fromElement(el);\n\n\t\t// Exit early if the link should be ignored\n\t\tif (this.shouldIgnoreVisit(href, { el, event })) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Ignore if swup is currently navigating towards the link's URL\n\t\tif (this.navigating && url === this.visit.to.url) {\n\t\t\tevent.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tthis.visit = this.createVisit({ to: url, hash, el, event });\n\n\t\t// Exit early if control key pressed\n\t\tif (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) {\n\t\t\tthis.hooks.call('link:newtab', { href });\n\t\t\treturn;\n\t\t}\n\n\t\t// Exit early if other than left mouse button\n\t\tif (event.button !== 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.hooks.callSync('link:click', { el, event }, () => {\n\t\t\tconst from = this.visit.from.url ?? '';\n\n\t\t\tevent.preventDefault();\n\n\t\t\t// Handle links to the same page\n\t\t\tif (!url || url === from) {\n\t\t\t\tif (hash) {\n\t\t\t\t\t// With hash: scroll to anchor\n\t\t\t\t\tthis.hooks.callSync('link:anchor', { hash }, () => {\n\t\t\t\t\t\tupdateHistoryRecord(url + hash);\n\t\t\t\t\t\tthis.scrollToContent();\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// Without hash: scroll to top or load/reload page\n\t\t\t\t\tthis.hooks.callSync('link:self', undefined, () => {\n\t\t\t\t\t\tswitch (this.options.linkToSelf) {\n\t\t\t\t\t\t\tcase 'navigate':\n\t\t\t\t\t\t\t\treturn this.performNavigation();\n\t\t\t\t\t\t\tcase 'scroll':\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tupdateHistoryRecord(url);\n\t\t\t\t\t\t\t\treturn this.scrollToContent();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Exit early if the resolved path hasn't changed\n\t\t\tif (this.isSameResolvedUrl(url, from)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Finally, proceed with loading the page\n\t\t\tthis.performNavigation();\n\t\t});\n\t}\n\n\tprotected handlePopState(event: PopStateEvent) {\n\t\tconst href: string = (event.state as HistoryState)?.url ?? location.href;\n\n\t\t// Exit early if this event should be ignored\n\t\tif (this.options.skipPopStateHandling(event)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Exit early if the resolved path hasn't changed\n\t\tif (this.isSameResolvedUrl(getCurrentUrl(), this.currentPageUrl)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { url, hash } = Location.fromUrl(href);\n\n\t\tthis.visit = this.createVisit({ to: url, hash, event });\n\n\t\t// Mark as history visit\n\t\tthis.visit.history.popstate = true;\n\n\t\t// Determine direction of history visit\n\t\tconst index = (event.state as HistoryState)?.index ?? 0;\n\t\tif (index && index !== this.currentHistoryIndex) {\n\t\t\tconst direction = index - this.currentHistoryIndex > 0 ? 'forwards' : 'backwards';\n\t\t\tthis.visit.history.direction = direction;\n\t\t\tthis.currentHistoryIndex = index;\n\t\t}\n\n\t\t// Disable animation & scrolling for history visits\n\t\tthis.visit.animation.animate = false;\n\t\tthis.visit.scroll.reset = false;\n\t\tthis.visit.scroll.target = false;\n\n\t\t// Animated history visit: re-enable animation & scroll reset\n\t\tif (this.options.animateHistoryBrowsing) {\n\t\t\tthis.visit.animation.animate = true;\n\t\t\tthis.visit.scroll.reset = true;\n\t\t}\n\n\t\t// Does this even do anything?\n\t\t// if (!hash) {\n\t\t// \tevent.preventDefault();\n\t\t// }\n\n\t\tthis.hooks.callSync('history:popstate', { event }, () => {\n\t\t\tthis.performNavigation();\n\t\t});\n\t}\n\n\t/** Determine whether an element will open a new tab when clicking/activating. */\n\tprotected triggerWillOpenNewWindow(triggerEl: Element) {\n\t\tif (triggerEl.matches('[download], [target=\"_blank\"]')) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["i", "value", "_a", "result", "x", "m", "i", "classify", "text", "fallback", "String", "toLowerCase", "replace", "getCurrentUrl", "hash", "location", "pathname", "search", "createHistoryRecord", "url", "customData", "data", "_extends", "random", "Math", "source", "history", "pushState", "updateHistoryRecord", "state", "replaceState", "delegateEvent", "selector", "type", "callback", "options", "controller", "AbortController", "signal", "delegate", "destroy", "abort", "Location", "URL", "constructor", "base", "document", "baseURI", "super", "toString", "this", "el", "href", "getAttribute", "matchPath", "path", "match", "error", "Error", "FetchError", "message", "details", "status", "aborted", "timedOut", "name", "async", "fetchPage", "_options$timeout", "fromUrl", "headers", "requestHeaders", "timeout", "response", "timeoutId", "setTimeout", "hooks", "call", "visit", "fetch", "clearTimeout", "responseUrl", "html", "finalUrl", "page", "cache", "write", "method", "set", "Cache", "swup", "pages", "Map", "size", "all", "copy", "forEach", "key", "has", "resolve", "get", "result", "callSync", "update", "payload", "delete", "clear", "undefined", "prune", "predicate", "urlToResolve", "resolveUrl", "query", "context", "querySelector", "queryAll", "Array", "from", "querySelectorAll", "nextTick", "Promise", "requestAnimationFrame", "isPromise", "obj", "then", "runAsPromise", "func", "args", "reject", "forceReflow", "element", "_element", "body", "offsetHeight", "escapeCssIdentifier", "ident", "window", "CSS", "escape", "toMs", "s", "Number", "slice", "Classes", "swupClasses", "selectors", "scope", "animation", "containers", "isArray", "join", "targets", "trim", "add", "classes", "target", "classList", "remove", "className", "split", "filter", "c", "isSwupClass", "some", "startsWith", "createVisit", "to", "currentPageUrl", "event", "id", "animate", "wait", "animationScope", "animationSelector", "trigger", "read", "action", "popstate", "direction", "scroll", "reset", "Hooks", "registry", "init", "hook", "create", "exists", "ledger", "console", "on", "handler", "warn", "registration", "off", "before", "once", "defaultHandler", "after", "getHandlers", "run", "dispatchDomEvent", "runSync", "registrations", "results", "push", "found", "replaced", "values", "sort", "sortRegistrations", "T", "length", "index", "createDefaultHandler", "next", "a", "b", "_a$priority", "_b$priority", "priority", "dispatchEvent", "CustomEvent", "detail", "getAnchorElement", "charAt", "substring", "decoded", "decodeURIComponent", "getElementById", "TRANSITION", "ANIMATION", "awaitAnimations", "elements", "animatedElements", "awaitedAnimations", "map", "propCount", "expectedType", "styles", "getComputedStyle", "transitionDelays", "getStyleProperties", "transitionDurations", "transitionTimeout", "calculateTimeout", "animationDelays", "animationDurations", "animationTimeout", "max", "endEvent", "startTime", "performance", "now", "propsTransitioned", "end", "removeEventListener", "onEnd", "includes", "elapsedTime", "addEventListener", "Boolean", "delays", "durations", "concat", "duration", "i", "navigate", "shouldIgnoreVisit", "performNavigation", "navigating", "referrer", "_options$cache$read", "_options$cache$write", "pagePromise", "cachedPage", "newUrl", "currentHistoryIndex", "animationPromise", "animatePageOut", "renderPage", "animatePageIn", "skipPopStateHandling", "go", "skip", "replaceContent", "_incomingDocument$que", "incomingDocument", "DOMParser", "parseFromString", "title", "innerText", "persistedElements", "currentEl", "incomingEl", "replaceWith", "existing", "replacement", "scrollToContent", "behavior", "scrollTarget", "scrolled", "anchor", "scrollIntoView", "scrollTo", "top", "left", "isSameResolvedUrl", "use", "plugin", "maybeInvalidPlugin", "isSwupPlugin", "_checkRequirements", "_beforeMount", "mount", "plugins", "unuse", "pluginOrName", "findPlugin", "unmount", "_afterUnmount", "p", "find", "url1", "url2", "defaults", "animateHistoryBrowsing", "ignoreVisit", "closest", "linkSelector", "linkToSelf", "Accept", "_event$state", "Swup", "_history$state$index", "_history$state", "version", "clickDelegate", "log", "handleLinkClick", "bind", "handlePopState", "checkRequirements", "enable", "_history$state2", "scrollRestoration", "documentElement", "origin", "triggerWillOpenNewWindow", "delegateTarget", "fromElement", "preventDefault", "metaKey", "ctrlKey", "shiftKey", "altKey", "button", "_this$visit$from$url", "_event$state$url", "_event$state2", "_event$state$index", "_event$state3", "triggerEl", "matches"]
}
